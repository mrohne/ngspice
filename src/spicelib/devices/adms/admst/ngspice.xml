<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst PUBLIC "-//noovela//DTD_ADMST 2.3.0//FR" "admst.dtd">
<!--
Tool 'ngspice.xml'
Copyright © 2011 Noovela - Author Laurent Lemaitre 
This code IS to be used for non-commercial usage ONLY.
Note: publishing technical papers with the affiliation of a commercial company
which results are produced by the tool are typical commercial usage of the tool. 
Commercial usage are subject to special fees.
Contact: r29173@noovela.com or www.noovela.com
-->
<admst xmlns:admst="http://mot-adms.sourceforge.net/adms/admst.xml" version="2.3.0">
<admst:value-to select="/#simulator" string="ngspice"/>
  <admst:variable name="zddx"/>
  <admst:variable name="ztmp"/>
  <admst:variable name="zprobe"/>
  <admst:variable name="pprobe"/>
  <admst:variable name="qprobe"/>
  <admst:variable name="e"/>
  <admst:variable name="ep"/>
  <admst:variable name="eq"/>
  <admst:variable name="epq"/>
  <admst:template match="e">
    <admst:apply-templates select="." match="%(datatypename)">$e</admst:apply-templates>
  </admst:template>
  <!--
* Returns the type of a variable. The returned type
* is either int, double, or char *. This template is
* used to create the mint:instance and model data structures.
-->
  <admst:template match="function">
    <admst:choose>
      <admst:when test="[arity='unary']">
        <admst:apply-templates select="." match="unary">
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[arity='binary']">
        <admst:apply-templates select="." match="binary">
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[arity='ternary']">
        <admst:apply-templates select="." match="ternary">
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[arity='nary']">
        <admst:apply-templates select="." match="nary">
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[arity='callfunction']">
        <admst:apply-templates select="." match="callfunction">
        </admst:apply-templates>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(.) arity=%(arity) unexpected in function\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="hxxfunction">
    <admst:choose>
      <admst:when test="[arity='unary']">
        <admst:apply-templates select="." match="hxxunary"/>
      </admst:when>
      <admst:when test="[arity='binary']">
        <admst:apply-templates select="." match="hxxbinary"/>
      </admst:when>
      <admst:when test="[arity='ternary']">
        <admst:apply-templates select="." match="hxxternary"/>
      </admst:when>
      <admst:when test="[arity='nary']">
        <admst:apply-templates select="." match="hxxnary"/>
      </admst:when>
      <admst:when test="[arity='callfunction']">
        <admst:apply-templates select="." match="hxxcallfunction"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(.) arity=%(arity) unexpected in hxxfunction\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="vtype">
    <admst:choose>
      <admst:when test="[type='integer']">int</admst:when>
      <admst:when test="[type='real']">double</admst:when>
      <admst:when test="[type='string']">char*</admst:when>
      <admst:otherwise>
        <admst:fatal format="variable type unknown\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="bname">
    <admst:choose>
      <admst:when test="[name='bw_equr']">
        <admst:return name="bname" string="^~"/>
      </admst:when>
      <admst:when test="[name='bw_equl']">
        <admst:return name="bname" string="~^"/>
      </admst:when>
      <admst:when test="[name='bw_xor']">
        <admst:return name="bname" string="^"/>
      </admst:when>
      <admst:when test="[name='bw_or']">
        <admst:return name="bname" string="|"/>
      </admst:when>
      <admst:when test="[name='bw_and']">
        <admst:return name="bname" string="&amp;"/>
      </admst:when>
      <admst:when test="[name='or']">
        <admst:return name="bname" string="||"/>
      </admst:when>
      <admst:when test="[name='and']">
        <admst:return name="bname" string="&amp;&amp;"/>
      </admst:when>
      <admst:when test="[name='equ']">
        <admst:return name="bname" string="=="/>
      </admst:when>
      <admst:when test="[name='notequ']">
        <admst:return name="bname" string="!="/>
      </admst:when>
      <admst:when test="[name='lt']">
        <admst:return name="bname" string="&lt;"/>
      </admst:when>
      <admst:when test="[name='lt_equ']">
        <admst:return name="bname" string="&lt;="/>
      </admst:when>
      <admst:when test="[name='gt']">
        <admst:return name="bname" string="&gt;"/>
      </admst:when>
      <admst:when test="[name='gt_equ']">
        <admst:return name="bname" string="&gt;="/>
      </admst:when>
      <admst:when test="[name='shiftr']">
        <admst:return name="bname" string="&gt;&gt;"/>
      </admst:when>
      <admst:when test="[name='shiftl']">
        <admst:return name="bname" string="&lt;&lt;"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="variable type unknown\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="funcname">
    <admst:choose>
      <admst:when test="[name='abs']">
        <admst:return name="fname" string="fabs"/>
      </admst:when>
      <admst:when test="[name='\$shrinkl']">
        <admst:return name="fname" string="shrinkl"/>
      </admst:when>
      <admst:when test="[name='\$shrinka']">
        <admst:return name="fname" string="shrinka"/>
      </admst:when>
      <admst:when test="[name='log']">
        <admst:return name="fname" string="log10"/>
      </admst:when>
      <admst:when test="[name='ln']">
        <admst:return name="fname" string="logE"/>
      </admst:when>
      <admst:when test="[name='limexp']">
        <admst:return name="fname" string="limexp"/>
      </admst:when>
      <admst:when test="[name='\$limexp']">
        <admst:return name="fname" string="limexp"/>
      </admst:when>
      <admst:otherwise>
        <admst:return name="fname" string="%(name)"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>

  <admst:template match="partition">
    <admst:value-to select="value/#module" path="$globalmodule"/>
    <admst:if
      test="[aname='rhs' or aname='ifcondition'  or aname='whilecondition' or
             aname='forcondition' or aname='default' or aname='casecondition' or
             (up/value/datatypename='function' and up/value/arity='callfunction' and aname='arguments')]">
      <admst:value-to select="#isexpression" path="1"/>
      <admst:variable name="globalexpression" path="value"/>
    </admst:if>
    <admst:choose>
      <admst:when test="value[datatypename='contribution']">
        <admst:variable name="globalcontribution" path="value"/>
      </admst:when>
      <admst:when test="value[datatypename='assignment']">
        <admst:variable name="globalassignment" path="value"/>
      </admst:when>
      <admst:when test="value[datatypename='probe' and not(tnode/up/value/datatypename='function' and tnode/up/value/name='ddx')]">
        <admst:push select="$globalexpression/@exprobe" path="value" oncompare="nature|pnode|nnode"/>
      </admst:when>
      <admst:when test="value[datatypename='block']">
        <admst:variable test="value[name='initial_instance']" name="globalpartitionning" string="initial_instance"/>
        <admst:variable test="value[name='load']" name="globalpartitionning" string="load"/>
        <admst:push select="value/#module/@allvariablecontainer" path="value"/>
      </admst:when>
      <admst:when test="value[datatypename='function' and arity!='callfunction']">
        <admst:value-to select="value/#expression" path="$globalexpression"/>
        <admst:value-to test="value[name='ddt']" select="$globalcontribution/#modifyd" path="1"/>
        <admst:value-to test="value[name='white_noise']" select="$globalcontribution/#modifywn" path="1"/>
        <admst:value-to test="value[name='flicker_noise']" select="$globalcontribution/#modifyfn" path="1"/>
        <admst:push
          test="value[arity='nary'
                 and not(name='\$realtime' or name='\$temperature' or name='vt' or name='idt' or name='ddt' or
                         name='\$param_given' or name='ddx' or name='flicker_noise' or name='white_noise')]"
            select="$globalexpression/@exfunction" path="value"/>
      </admst:when>
      <admst:when test="value[datatypename='variable']">
        <admst:value-to test="value[$globalpartitionning='load']" select="value/prototype/#inevaluate" string="yes"/>
        <admst:value-to test="value[$globalpartitionning='initial_instance']" select="value/prototype/#ininstance" string="yes"/>
        <admst:push select="value/prototype/@protoinstance" path="value"/>
        <admst:push select="$globalexpression/@exvariable" path="value" oncompare="name"/>
        <admst:push select="$globalexpression/@exprobe" path="value/prototype/@vpprobe" oncompare="nature|pnode|nnode"/>
      </admst:when>
    </admst:choose>
    <admst:apply-templates select="down" match="partition"/>
    <admst:choose>
      <admst:when test="[#isexpression=1]">
        <admst:variable name="globalexpression"/>
      </admst:when>
      <admst:when test="value[datatypename='contribution']">
        <admst:variable name="globalcontribution"/>
        <admst:push select="value/$globalmodule/@contribution" path="value"/>
        <admst:variable name="myklass" path="value/#module/@npncontributionklass[nature=../../nature and pnode=../../pnode and nnode=../../nnode]"/>
        <admst:if test="[nilled($myklass)]">
          <admst:variable name="myklass" path="value"/>
          <admst:push select="$globalmodule/@npncontributionklass" path="value"/>
        </admst:if>
        <admst:value-to select="value/#zcontrib" path="$myklass"/>
        <admst:push select="$myklass/@kcontribution" path="value"/>
        <admst:push select="$myklass/@kprobe" path="value/rhs/@exprobe" oncompare="nature|pnode|nnode"/>
      </admst:when>
      <admst:when test="value[datatypename='assignment']">
        <admst:push select="value/lhs/prototype/@vpprobe" path="value/rhs/@exprobe" oncompare="nature|pnode|nnode"/>
        <admst:push select="$globalmodule/@assignment" path="value"/>
      </admst:when>
    </admst:choose>
  </admst:template>
  <admst:template match="init">
    <admst:choose>
      <admst:when test="[datatypename='function' and arity='callfunction']">
        <admst:apply-templates select="arguments" match="e:init"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whilecondition" match="e:init"/>
        <admst:apply-templates select="whilecode" match="init"/>
      </admst:when>
      <admst:when test="[datatypename='forloop']">
        <admst:apply-templates select="forinitial|forupdate" match="init"/>
        <admst:apply-templates select="forcondition" match="e:init"/>
        <admst:apply-templates select="forcode" match="init"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="casecondition" match="e:init"/>
        <admst:variable name="globaltreenode"/>
        <admst:for-each select="caseitem">
          <admst:for-each select="casealternative">
            <admst:variable name="globaltreenode" path="."/>
            <admst:apply-templates select="." match="e:init"/>
            <admst:variable name="globaltreenode"/>
          </admst:for-each>
          <admst:apply-templates select="casecode" match="init"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:push select="$globalmodule/@conditional" path="."/>
        <admst:apply-templates select="ifcondition" match="e:init"/>
        <admst:apply-templates select="thencode|elsecode" match="init"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:value-to select="#module" path="$globalmodule"/>
        <admst:variable name="globalcontribution" path="."/>
        <admst:apply-templates select="rhs" match="e:init"/>
        <admst:variable name="globalcontribution"/>
        <admst:push select="$globalmodule/@reversecontribution" path="."/>
        <admst:variable name="myklass" path="#module/@npncontributionklass[nature=../../nature and pnode=../../pnode and nnode=../../nnode]"/>
        <admst:if test="[nilled($myklass)]">
          <admst:variable name="myklass" path="."/>
          <admst:push select="$globalmodule/@npncontributionklass" path="."/>
        </admst:if>
        <admst:value-to select="#zcontrib" path="$myklass"/>
        <admst:push select="$myklass/@kcontribution" path="."/>
        <admst:push select="$myklass/@kprobe" path="rhs/@exprobe" oncompare="nature|pnode|nnode"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:value-to select="#module" path="$globalmodule"/>
        <admst:variable name="globalassignment" path="."/>
        <admst:apply-templates select="rhs" match="e:init"/>
        <admst:push select="$globalmodule/@assignment" path="."/>
        <admst:push select="lhs/prototype/@protoinstance" path="lhs"/>
      </admst:when>
      <admst:when test="[datatypename='block']">
        <admst:value-to select="#module" path="$globalmodule"/>
        <admst:push select="$globalmodule/@block" path="."/>
        <admst:apply-templates select="blockcode" match="init"/>
        <admst:push select="$globalmodule/@allvariablecontainer" path="."/>
      </admst:when>
      <admst:when test="[datatypename='nilled']"/>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): case not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="e:init">
    <admst:choose>
      <admst:when test="[caller()/template/textmatch/value='init']">
        <admst:variable name="globalexpression" path="."/>
        <admst:apply-templates select="." match="e:init"/>
        <admst:variable name="globalexpression"/>
      </admst:when>
      <admst:when test="[datatypename='probe']">
        <admst:value-to select="#module" path="$globalmodule"/>
        <admst:push select="$globalmodule/@moduleprobe" path="." oncompare="nature|pnode|nnode"/>
      </admst:when>
      <admst:when test="[datatypename='variable']">
        <admst:push select="$globalexpression/@exvariable" path="." oncompare="name"/>
        <admst:push select="$globaltreenode/@variable" path="." oncompare="prototype"/>
        <admst:push select="prototype/@protoinstance" path="."/>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='unary')]">
        <admst:apply-templates select="arguments[1]" match="e:init"/>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='binary')]">
        <admst:apply-templates select="arguments[1]|arguments[2]" match="e:init"/>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='ternary')]">
        <admst:apply-templates select="arguments[1]|arguments[2]|arguments[3]" match="e:init"/>
      </admst:when>
      <admst:when test="[datatypename='function']">
        <admst:choose>
          <admst:when test="[name='ddx']">
            <admst:value-to select="$globalassignment/lhs/prototype/#derivate" string="yes"/>
            <admst:apply-templates select="arguments[1]" match="e:init"/>
            <!-- fixme admst:apply-templates select="" match="e:init"/ -->
            <admst:push select="$globalmodule/@moduleprobe" path="arguments[2]" oncompare="nature|pnode|nnode"/>
            <admst:push select="$globalexpression/@exvariable/prototype/@ddxprobe" path="arguments[2]" oncompare="nature|pnode|nnode"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="arguments" match="e:init"/>
          </admst:otherwise>
        </admst:choose>
        <admst:choose>
          <admst:when test="[name='\$realtime' or name='\$temperature' or name='\$vt' or name='idt' or name='ddt' or                            name='\$param_given' or name='\$param_given' or name='ddx' or name='flicker_noise' or name='white_noise']"/>
          <!--Trigonometric and hyperbolic functions-->
          <admst:when test="[             name='sin' or name='cos' or name='tan' or name='asin' or name='acos' or name='atan' or             name='atan2' or name='hypot' or             name='sinh' or name='cosh' or name='tanh' or name='asinh' or name='acosh' or name='atanh'           ]">
            <admst:push select="$globalexpression/@exxfunction" path="."/>
            <admst:value-to select="#class" string="builtin"/>
          </admst:when>
          <!--standard functions-->
          <admst:when test="[             name='ln' or name='log' or name='exp' or name='sqrt' or             name='min' or name='max' or             name='abs' or name='pow' or name='floor' or name='ceil'           ]">
            <admst:push select="$globalexpression/@exxfunction" path="."/>
            <admst:value-to select="#class" string="builtin"/>
          </admst:when>
          <!--other functions-->
          <admst:when test="[name='analysis' or name='simparam' or name='\$limexp' or name='limexp']">
            <admst:push select="$globalexpression/@exxfunction" path="."/>
            <admst:value-to select="#class" string="builtin"/>
          </admst:when>
          <!--not standard-->
          <admst:when test="[name='div' or name='\$analysis' or name='\$simparam' or name='\$shrinka' or name='\$shrinkl']">
            <admst:push select="$globalexpression/@exxfunction" path="."/>
            <admst:value-to select="#class" string="builtin"/>
          </admst:when>
          <admst:otherwise>
            <admst:assert test="[exists(definition)]" format="%(lexval/(f|':'|l|':'|c)): functionp '%(name)' is undefined\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to select="#unique_id" path="$globalmodule/#modulefunctionidx"/>
        <admst:value-to select="$globalmodule/#modulefunctionidx" path="$globalmodule/#modulefunctionidx+1"/>
        <admst:value-to select="#expression" path="$globalexpression"/>
        <!-- fixme: these flags should be set after all contribs are transformed to ...&lt;+F(...); canonical form -->
        <admst:value-to test="[name='ddt']" select="$globalcontribution/#modifyd" path="1"/>
        <admst:value-to test="[name='white_noise']" select="$globalcontribution/#modifywn" path="1"/>
        <admst:value-to test="[name='flicker_noise']" select="$globalcontribution/#modifyfn" path="1"/>
        <admst:push select="$globalmodule/@mfunction" path="."/>
      </admst:when>
      <admst:when test="[datatypename='number']">
        <admst:value-to test="[scalingunit='1' and (value='0' or value='0.0')]" select="#nval" string="0.0"/>
      </admst:when>
      <admst:when test="[datatypename='string']"/>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): case not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="e:#dependency">
    <admst:choose>
      <admst:when test="caller()/template/textmatch[value='dependency']">
        <admst:variable name="globalexpression" path="."/>
        <admst:apply-templates select="." match="e:#dependency"/>
        <admst:variable name="globalexpression"/>
        <admst:value-to select="#dependency" path="#dependency"/>
        <admst:value-to select="#dependency[.='constant' and $globalopdependent='yes']" string="noprobe"/>
      </admst:when>
      <admst:when test="caller()/template/textmatch[value='main.module']">
        <admst:variable name="globalexpression" path="."/>
        <admst:apply-templates select="." match="e:#dependency"/>
        <admst:variable name="globalexpression"/>
        <admst:value-to select="#dependency[.='constant' and $globalopdependent='yes']" string="noprobe"/>
      </admst:when>
      <admst:when test="[datatypename='probe']">
        <admst:value-to select="#dependency" string="linear"/>
      </admst:when>
      <admst:when test="[datatypename='variable']">
        <admst:choose>
          <admst:when test="[exists(prototype/@protoinstance[#dependency='linear'])]">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[exists(prototype/@protoinstance[#dependency='noprobe'])]">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='unary')]">
        <admst:apply-templates select="arguments[1]" match="e:#dependency"/>
        <admst:value-to select="#dependency" path="arguments[1]/#dependency"/>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='binary')]">
        <admst:apply-templates select="arguments[1]|arguments[2]" match="e:#dependency"/>
        <!--
        +:             -:            *:            /:                                                          
          c  np l  nl    c  np l  nl   c  np l  nl   c  np nl nl                                                          
          np np l  nl    np np l  nl   np np l  nl   np np nl nl                                                          
          l  l  l  nl    l  l  l  nl   l  l  nl nl   l  l  nl nl                                                          
          nl nl nl nl    nl nl nl nl   nl nl nl nl   nl nl nl nl                                                          
      -->
        <admst:choose>
          <admst:when test="[arguments[1]/#dependency='linear' or arguments[2]/#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[arguments[1]/#dependency='noprobe' or arguments[2]/#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='ternary')]">
        <admst:apply-templates select="arguments[1]|arguments[2]|arguments[3]" match="e:#dependency"/>
        <!--
          ?: - arguments[1]=c -  - arguments[1]!=c -                                                            
             c  np l  nl np np l  nl                                                             
             np np l  nl np np l  nl                                                             
             l  l  l  nl l  l  l  nl                                                             
             nl nl nl nl nl nl nl nl                                                             
      -->
        <admst:choose>
          <admst:when test="[arguments[2]/#dependency='linear' or arguments[3]/#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[arguments[1]/#dependency!='constant' or arguments[2]/#dependency='noprobe' or arguments[3]/#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='function']">
        <admst:value-to test="[name='\$temperature']" select="$globalassignment/lhs/#TemperatureDependent" string="yes"/>
        <admst:choose>
          <admst:when test="[name='ddx' or name='\$ddx']">
            <admst:apply-templates select="arguments[1]" match="e:#dependency"/>
            <admst:choose>
              <admst:when test="arguments[1]/#dependency[.='constant' or .='noprobe']">
                <admst:value-to select="#dependency" path="arguments[1]/#dependency"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="#dependency" string="linear"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="arguments" match="e:#dependency"/>
            <admst:choose>
              <admst:when test="arguments[#dependency='linear']">
                <admst:value-to select="#dependency" string="linear"/>
              </admst:when>
              <admst:when test="arguments/#dependency[.='noprobe']">
                <admst:value-to select="#dependency" string="noprobe"/>
              </admst:when>
              <admst:otherwise>
                <admst:value-to select="#dependency" string="constant"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="[#dependency='linear']" select="$globalexpression/#hasVoltageDependentFunction" string="yes"/>
      </admst:when>
      <admst:when test="[datatypename='number']">
        <admst:value-to select="#dependency" string="constant"/>
      </admst:when>
      <admst:when test="[datatypename='string']">
        <admst:value-to select="#dependency" string="constant"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): case not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="dependency">
    <admst:choose>
      <admst:when test="[datatypename='function' and arity='callfunction']">
        <admst:apply-templates select="arguments" match="e:#dependency"/>
        <admst:value-to select="#dependency" path="#dependency"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <!--
        w, logic(D,whilecondition.d)            , d=wb.d                                               
              c                 !c                           
           c  wb,w,!c?(D,wb,!D) D,wb,!D                                                                                        
           !c wb                wb                                                                                             
      -->
        <admst:apply-templates select="whilecondition" match="e:#dependency"/>
        <admst:apply-templates select="[$globalopdependent='yes' or whilecondition/#dependency='constant']/whilecode" match="dependency"/>
        <admst:if test="[$globalopdependent='no']">
          <admst:apply-templates select="whilecondition[#dependency='constant']" match="e:#dependency"/>
          <admst:if test="[whilecondition/#dependency!='constant']">
            <admst:variable name="globalopdependent" string="yes"/>
            <admst:apply-templates select="whilecode" match="dependency"/>
            <admst:variable name="globalopdependent" string="no"/>
          </admst:if>
        </admst:if>
        <!--
          wl:  w=c          w!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
        <admst:choose>
          <admst:when test="[whilecode/#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[whilecondition/#dependency!='constant' or whilecode/#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='forloop']">
        <admst:apply-templates select="forinitial|forupdate" match="dependency"/>
        <admst:apply-templates select="forcondition" match="e:#dependency"/>
        <admst:apply-templates select="[$globalopdependent='yes' or nilled((forinitial|forcondition|forupdate)/[#dependency!='constant'])]/forcode" match="dependency"/>
        <admst:if test="[$globalopdependent='no']">
          <admst:apply-templates select="(forinitial|forupdate)/[#dependency='constant']" match="dependency"/>
          <admst:apply-templates select="forcondition[#dependency='constant']" match="e:#dependency"/>
          <admst:if test="[forcondition/#dependency!='constant' or forinitial/#dependency!='constant' or forupdate/#dependency!='constant']">
            <admst:variable name="globalopdependent" string="yes"/>
            <admst:apply-templates select="forcode" match="dependency"/>
            <admst:variable name="globalopdependent" string="no"/>
          </admst:if>
        </admst:if>
        <!--
          fl:  f=c          f!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
        <admst:choose>
          <admst:when test="[forcode/#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[(forcondition!='constant' or forinitial!='constant' or forupdate!='constant') or forcode/#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="casecondition" match="e:#dependency"/>
        <admst:for-each select="caseitem">
          <admst:for-each select="casealternative">
            <admst:apply-templates select="." match="e:#dependency"/>
          </admst:for-each>
          <admst:apply-templates select="casecode" match="dependency"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="ifcondition" match="e:#dependency"/>
        <admst:choose>
          <admst:when test="[$globalopdependent='no' and ifcondition/#dependency!='constant']">
            <admst:variable name="globalopdependent" string="yes"/>
            <admst:apply-templates select="thencode|elsecode" match="dependency"/>
            <admst:variable name="globalopdependent" string="no"/>
          </admst:when>
          <admst:otherwise>
            <admst:apply-templates select="thencode|elsecode" match="dependency"/>
          </admst:otherwise>
        </admst:choose>
        <!--
          cd:  i=c          i!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
        <admst:choose>
          <admst:when test="[thencode/#dependency='linear' or elsecode/#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[ifcondition/#dependency!='constant' or thencode/#dependency='noprobe' or elsecode/#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:apply-templates select="rhs" match="e:#dependency"/>
        <admst:value-to select="#dependency" string="linear"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:choose>
          <admst:when test="[$globalpartitionning='initial_model']">
            <admst:value-to select="lhs/prototype/#setinmodel" string="yes"/>
          </admst:when>
          <admst:when test="[$globalpartitionning='initial_instance']">
            <admst:value-to select="lhs/prototype/#setininstance" string="yes"/>
          </admst:when>
          <admst:when test="[$globalpartitionning='initial_step']">
            <admst:value-to select="lhs/prototype/#setininitial_step" string="yes"/>
          </admst:when>
          <admst:when test="[$globalpartitionning='noise']">
            <admst:value-to select="lhs/prototype/#setinnoise" string="yes"/>
          </admst:when>
          <admst:when test="[$globalpartitionning='final_step']">
            <admst:value-to select="lhs/prototype/#setinfinal" string="yes"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="lhs/prototype/#setinevaluate" string="yes"/>
          </admst:otherwise>
        </admst:choose>
        <admst:variable name="globalassignment" path="."/>
        <admst:apply-templates select="rhs" match="e:#dependency"/>
        <admst:value-to test="rhs/@exvariable[#TemperatureDependent='yes']" select="lhs/#TemperatureDependent" string="yes"/>
        <!--
        d=rhs.d,d=(c and D)?np
        l(l,r,$globalopdependent)
        $globalopdependent='no'  $globalopdependent='yes'
        c  np l  nl               np np l  nl
        np np l  nl               np np l  nl
        l  l  l  nl               l  l  l  nl
        nl nl nl nl               nl nl nl nl
      -->
        <admst:value-to select="#dependency" path="rhs/#dependency"/>
        <admst:choose>
          <admst:when test="[rhs/#dependency='linear' or exists(lhs/prototype/@protoinstance[#dependency='linear'])]">
            <admst:value-to select="lhs/#dependency" string="linear"/>
          </admst:when>
          <admst:when test="[$globalopdependent='yes' or rhs/#dependency='noprobe' or exists(lhs/prototype/@protoinstance[#dependency='noprobe'])]">
            <admst:value-to select="lhs/#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="lhs/#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='block']">
        <admst:variable name="forcepartitionning" string="yes"/>
        <admst:choose>
          <admst:when test="[name='initial_model']">
            <admst:variable name="globalpartitionning" string="initial_model"/>
          </admst:when>
          <admst:when test="[name='initial_instance']">
            <admst:variable name="globalpartitionning" string="initial_instance"/>
          </admst:when>
          <admst:when test="[name='initial_step']">
            <admst:variable name="globalpartitionning" string="initial_step"/>
          </admst:when>
          <admst:when test="[name='noise']">
            <admst:variable name="globalpartitionning" string="noise"/>
          </admst:when>
          <admst:when test="[name='final_step']">
            <admst:variable name="globalpartitionning" string="final_step"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="forcepartitionning" string="no"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="blockcode" match="dependency"/>
        <admst:variable test="[$forcepartitionning='yes']" name="globalpartitionning"/>
        <admst:choose>
          <admst:when test="blockcode[#dependency='linear']">
            <admst:value-to select="#dependency" string="linear"/>
          </admst:when>
          <admst:when test="blockcode[#dependency='noprobe']">
            <admst:value-to select="#dependency" string="noprobe"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#dependency" string="constant"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='nilled']"/>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): case not handled\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="main.module">
    <admst:variable name="globalmodule" path="."/>
    <admst:for-each select="modulenode">
      <admst:value-to select="#module" path=".."/>
    </admst:for-each>
    <admst:value-to select="#modulefunctionidx" path="0"/>
    <admst:apply-templates select="(modulefunctionp/functionpcode)|(modulecode)" match="init"/>
    <admst:apply-templates select="(modulefunctionp/functionpcode)|(modulecode)" match="dependency"/>
    <admst:apply-templates select="tnode" match="partition"/>
    <admst:push select="@contribution" path="@reversecontribution"/>
    <admst:for-each select="modulevariablep">
      <admst:value-to select="[exists(@protoinstance[#dependency!='constant'])]/#OPdependent" string="yes"/>
      <admst:value-to select="#output" path="isparameter"/>
      <admst:value-to select="[isparameter='yes']/#parametertype" string="model"/>
      <admst:for-each select="attribute">
        <admst:value-to select="[name='type' and value='instance']/../#parametertype" string="instance"/>
        <admst:value-to select="[name='ask' and value='yes']/../#output" string="yes"/>
        <admst:value-to select="[name='ask' and value='no']/../#output" string="no"/>
      </admst:for-each>
      <admst:value-to select="#scope"
         test="[#parametertype='instance' or (isparameter='no' and (#ininstance='yes' and #inevaluate='yes'))]"
         string="global_instance"/>
      <admst:apply-templates select="default" match="e:#dependency"/>
      <admst:value-to select="default[exists([(datatypename='function' and arity='unary') and name='minus' and arguments[1]/datatypename='number' and arguments[1]/value='1.0'])]/#exvalue"
        string="is_neg_one"/>
      <admst:value-to select="default[exists([datatypename='number' and value='0.0'])]/#exvalue" string="is_zero"/>
      <admst:value-to select="default[exists([datatypename='number' and value='1.0'])]/#exvalue" string="is_one"/>
      <admst:value-to select="#isstate"
        test="[isparameter='no' and #scope='global_instance' and #setininitial_step='yes' and (#setinevaluate='yes' or #usedinevaluate='yes')]"
        string="yes"/>
    </admst:for-each>
    <admst:template match="modify">
      <admst:choose>
        <admst:when test="[datatypename='block']">
          <admst:apply-templates select="reverse(blockcode)" match="modify"/>
          <admst:value-to test="blockcode[#modifys=1]" select="#modifys" path="1"/>
          <admst:value-to test="blockcode[#modifyd=1]" select="#modifyd" path="1"/>
          <admst:value-to test="blockcode[#modifyfn=1]" select="#modifyfn" path="1"/>
          <admst:value-to test="blockcode[#modifywn=1]" select="#modifywn" path="1"/>
          <admst:value-to test="blockcode[#modifyc=1]" select="#modifyc" path="1"/>
        </admst:when>
        <admst:when test="[datatypename='conditional']">
          <admst:apply-templates select="elsecode|thencode" match="modify"/>
          <admst:value-to test="[thencode/#modifys=1 or elsecode/#modifys=1]" select="#modifys|ifcondition/@exvariable/#modifys" path="1"/>
          <admst:value-to test="[thencode/#modifyd=1 or elsecode/#modifyd=1]" select="#modifyd|ifcondition/@exvariable/#modifyd" path="1"/>
          <admst:value-to test="[thencode/#modifyfn=1 or elsecode/#modifyfn=1]" select="#modifyfn|ifcondition/@exvariable/#modifyfn" path="1"/>
          <admst:value-to test="[thencode/#modifywn=1 or elsecode/#modifywn=1]" select="#modifywn|ifcondition/@exvariable/#modifywn" path="1"/>
          <admst:value-to test="[thencode/#modifyc=1 or elsecode/#modifyc=1]" select="#modifyc|ifcondition/@exvariable/#modifyc" path="1"/>
        </admst:when>
        <admst:when test="[datatypename='whileloop']">
          <admst:apply-templates select="whilecode" match="modify"/>
          <admst:value-to test="[whilecode/#modifys=1]" select="#modifys|whilecondition/@exvariable/#modifys" path="1"/>
          <admst:value-to test="[whilecode/#modifyd=1]" select="#modifyd|whilecondition/@exvariable/#modifyd" path="1"/>
          <admst:value-to test="[whilecode/#modifyfn=1]" select="#modifyfn|whilecondition/@exvariable/#modifyfn" path="1"/>
          <admst:value-to test="[whilecode/#modifywn=1]" select="#modifywn|whilecondition/@exvariable/#modifywn" path="1"/>
          <admst:value-to test="[whilecode/#modifyc=1]" select="#modifyc|whilecondition/@exvariable/#modifyc" path="1"/>
          <admst:apply-templates select="whilecode" match="modify"/>
        </admst:when>
        <admst:when test="[datatypename='forloop']">
          <admst:apply-templates select="forcode" match="modify"/>
          <admst:value-to test="[forcode/#modifys=1]" select="#modifys" path="1"/>
          <admst:value-to test="[forcode/#modifyd=1]" select="#modifyd" path="1"/>
          <admst:value-to test="[forcode/#modifyfn=1]" select="#modifyfn" path="1"/>
          <admst:value-to test="[forcode/#modifywn=1]" select="#modifywn" path="1"/>
          <admst:value-to test="[forcode/#modifyc=1]" select="#modifyc" path="1"/>
          <admst:apply-templates select="forcode" match="modify"/>
        </admst:when>
        <admst:when test="[datatypename='case']">
          <admst:apply-templates select="caseitem/casecode" match="modify"/>
          <admst:for-each select="caseitem">
            <admst:value-to test="[casecode/#modifys=1 and defaultcase='no']" select="#modifys|casealternative/@variable/#modifys" path="1"/>
            <admst:value-to test="[casecode/#modifyd=1 and defaultcase='no']" select="#modifyd|casealternative/@variable/#modifyd" path="1"/>
            <admst:value-to test="[casecode/#modifyfn=1 and defaultcase='no']" select="#modifyfn|casealternative/@variable/#modifyfn" path="1"/>
            <admst:value-to test="[casecode/#modifywn=1 and defaultcase='no']" select="#modifywn|casealternative/@variable/#modifywn" path="1"/>
            <admst:value-to test="[casecode/#modifyc=1 and defaultcase='no']" select="#modifyc|casealternative/@variable/#modifyc" path="1"/>
          </admst:for-each>
          <admst:value-to test="caseitem[#modifys=1]" select="#modifys|casecondition/@variable/#modifys" path="1"/>
          <admst:value-to test="caseitem[#modifyd=1]" select="#modifyd|casecondition/@variable/#modifyd" path="1"/>
          <admst:value-to test="caseitem[#modifyfn=1]" select="#modifyfn|casecondition/@variable/#modifyfn" path="1"/>
          <admst:value-to test="caseitem[#modifywn=1]" select="#modifywn|casecondition/@variable/#modifywn" path="1"/>
          <admst:value-to test="caseitem[#modifyc=1]" select="#modifyc|casecondition/@variable/#modifyc" path="1"/>
        </admst:when>
        <admst:when test="[datatypename='assignment']">
          <admst:value-to test="lhs[exists(prototype/@protoinstance[#modifys=1])]" select="#modifys|rhs/@exvariable/#modifys" path="1"/>
          <admst:value-to test="lhs[exists(prototype/@protoinstance[#modifyd=1])]" select="#modifyd|rhs/@exvariable/#modifyd" path="1"/>
          <admst:value-to test="lhs[exists(prototype/@protoinstance[#modifyfn=1])]" select="#modifyfn|rhs/@exvariable/#modifyfn" path="1"/>
          <admst:value-to test="lhs[exists(prototype/@protoinstance[#modifywn=1])]" select="#modifywn|rhs/@exvariable/#modifywn" path="1"/>
          <admst:value-to test="lhs[exists(prototype/@protoinstance[#modifyc=1])]" select="#modifyc|rhs/@exvariable/#modifyc" path="1"/>
          <admst:value-to test="lhs/prototype/@ddxprobe" select="#TOTOddxprobe" string="yes"/>
          <admst:push select="rhs/@exvariable/prototype/@ddxprobe" path="lhs/prototype/@ddxprobe" oncompare="nature|pnode|nnode"/>
        </admst:when>
        <admst:when test="[datatypename='contribution']">
          <admst:choose>
            <admst:when test="[#modifyd=1]">
              <admst:value-to select="rhs/@exvariable/#modifyd" path="1"/>
            </admst:when>
            <admst:when test="[#modifyfn=1]">
              <admst:value-to select="rhs/@exvariable/#modifyfn" path="1"/>
            </admst:when>
            <admst:when test="[#modifywn=1]">
              <admst:value-to select="rhs/@exvariable/#modifywn" path="1"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="#modifys|(rhs|rhs/@exvariable)/#modifys" path="1"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[datatypename='nilled']"/>
        <admst:when test="[datatypename='function' and arity='callfunction']">
          <admst:value-to select="#modifyc|arguments/@exvariable/#modifyc" path="1"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="%(datatypename): case not handled\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:apply-templates select="modulecode" match="modify"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifys=1])]/#modifys" path="1"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifyd=1])]/#modifyd" path="1"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifyfn=1])]/#modifyfn" path="1"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifywn=1])]/#modifywn" path="1"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifyc=1])]/#modifyc" path="1"/>
    <admst:value-to select="modulevariablep[exists(@protoinstance[#modifys=1 or #modifyd=1 or #modifyfn=1 or #modifywn=1])]/#insource" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifys=1])]/#modifys" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifyd=1])]/#modifyd" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifyfn=1])]/#modifyfn" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifywn=1])]/#modifywn" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifyc=1])]/#modifyc" path="1"/>
    <admst:value-to select="@allvariablecontainer/blockvariablep[exists(@protoinstance[#modifys=1 or #modifyd=1 or #modifyfn=1 or #modifywn=1])]/#insource" path="1"/>
    <!-- jacobian -->
    <admst:template match="j">
      <admst:break test="[#r/location='ground' or #c/location='ground']"/>
      <admst:variable name="myklass" path="#module/@jacobianklass[#row=../../#r and #column=../../#c]"/>
      <admst:if test="[nilled($myklass)]">
       <admst:new datatype="number" inputs="0">
         <admst:variable name="myklass" path="."/>
         <admst:push select="../#module/@jacobianklass" path="."/>
         <admst:value-to select="#module" path="../../../#module"/>
         <admst:value-to select="#row" path="../#r"/>
         <admst:value-to select="#column" path="../#c"/>
       </admst:new>
      </admst:if>
      <admst:push select="$myklass/@jcontribution" path="../.."/>
      <admst:variable name="p"/>
    </admst:template>
    <admst:for-each select="@contribution">
      <admst:variable name="mysource" path="."/>
      <admst:push select="#zcontrib/@jcontribution" path="."/>
      <!-- case I() &lt;+ .V(). -->
      <admst:for-each select="rhs/@exprobe[(nature=pnode/discipline/potential)and($mysource/nature=$mysource/pnode/discipline/flow)]">
        <admst:value-to select="#r" path="$mysource/pnode"/>
        <admst:value-to select="#c" path="pnode"/>
        <admst:apply-templates select="." match="j"/>
        <admst:value-to select="#r" path="$mysource/pnode"/>
        <admst:value-to select="#c" path="nnode"/>
        <admst:apply-templates select="." match="j"/>
        <admst:value-to select="#r" path="$mysource/nnode"/>
        <admst:value-to select="#c" path="pnode"/>
        <admst:apply-templates select="." match="j"/>
        <admst:value-to select="#r" path="$mysource/nnode"/>
        <admst:value-to select="#c" path="nnode"/>
        <admst:apply-templates select="." match="j"/>
      </admst:for-each>
    </admst:for-each>
  </admst:template>

  <admst:template match="main">
    <admst:push select="/@discipline" path="/items[datatypename='discipline']"/>
    <admst:push select="/@nature" path="/items[datatypename='nature']"/>
    <admst:push select="/@module" path="/items[datatypename='module']"/>
    <admst:for-each select="@nature">
      <admst:value-to select="ddt_nature" path="/@nature[name='%(../../ddt_name)']"/>
      <admst:value-to select="idt_nature" path="/@nature[name='%(../../idt_name)']"/>
    </admst:for-each>
    <admst:apply-templates select="/@module" match="main.module"/>
  </admst:template>
  <admst:template match="af:c:math_h">
/* math functions and appropriate derivatives */
inline double _cos(double arg)             { return  cos(arg); }
inline double _d0_cos(double arg)          { return (-sin(arg)); }
inline double _sin(double arg)             { return  sin(arg); }
inline double _d0_sin(double arg)          { return (cos(arg)); }
inline double _tan(double arg)             { return  tan(arg); }
inline double _d0_tan(double arg)          { return (1.0/cos(arg)/cos(arg)); }
inline double _cosh(double arg)            { return  cosh(arg); }
inline double _d0_cosh(double arg)         { return (sinh(arg)); }
inline double _sinh(double arg)            { return  sinh(arg); }
inline double _d0_sinh(double arg)         { return (cosh(arg)); }
inline double _tanh(double arg)            { return  tanh(arg); }
inline double _d0_tanh(double arg)         { return (1.0/cosh(arg)/cosh(arg)); }
inline double _acos(double arg)            { return  acos(arg); }
inline double _d0_acos(double arg)         { return (-1.0/sqrt(1-arg*arg)); }
inline double _asin(double arg)            { return  asin(arg); }
inline double _d0_asin(double arg)         { return (+1.0/sqrt(1-arg*arg)); }
inline double _atan(double arg)            { return  atan(arg); }
inline double _d0_atan(double arg)         { return (+1.0/(1+arg*arg)); }
inline double _logE(double arg)            { return  log(arg); }
inline double _d0_logE(double arg)         { return (1.0/arg); }
inline double _log10(double arg)           { return  log10(arg); }
inline double _d0_log10(double arg)        { return (1.0/arg/log(10.0)); }
inline double _exp(double arg)             { return  exp(arg); }
inline double _d0_exp(double arg)          { return exp(arg); }
inline double _sqrt(double arg)            { return  sqrt(arg); }
inline double _d0_sqrt(double arg)         { return (1.0/sqrt(arg)/2.0); }
inline double _abs(double arg)             { return  fabs(arg); }
inline double _d0_abs(double arg)          { return (((arg)&gt;=0)?(+1.0):(-1.0)); }
inline int _floor(double arg)              { return  floor(arg); }
inline int _d0_floor(double)               { return (1.0); }

inline double _hypot(double x,double y)    { return sqrt((x)*(x)+(y)*(y)); }
inline double _d0_hypot(double x,double y) { return (x)/sqrt((x)*(x)+(y)*(y)); }
inline double _d1_hypot(double x,double y) { return (y)/sqrt((x)*(x)+(y)*(y)); }

inline double _max(double x,double y)      { return ((x)&gt;(y))?(x):(y); }
inline double _d0_max(double x,double y)   { return ((x)&gt;(y))?1.0:0.0; }
inline double _d1_max(double x,double y)   { return ((x)&gt;(y))?0.0:1.0; }

inline double _min(double x,double y)      { return ((x)&lt;(y))?(x):(y); }
inline double _d0_min(double x,double y)   { return ((x)&lt;(y))?1.0:0.0; }
inline double _d1_min(double x,double y)   { return ((x)&lt;(y))?0.0:1.0; }

inline double _pow(double x,double y)      { return pow(x,y); }
inline double _d0_pow(double x,double y)   { return (x==0.0)?0.0:((y/x)*pow(x,y)); }
inline double _d1_pow(double x,double y)   { return (x==0.0)?0.0:((log(x)/exp(0.0))*pow(x,y)); }

inline double _limexp(double arg)          { return ((arg)&lt;(80))?(exp(arg)):(exp(80.0)*(1.0+(arg-80))); }
inline double _d0_limexp(double arg)       { return ((arg)&lt;(80))?(exp(arg)):(exp(80.0)); }

inline double _vt(double arg)              { return 1.3806503e-23*arg/1.602176462e-19; }
inline double _d0_vt(double)               { return 1.3806503e-23/1.602176462e-19; }

</admst:template>
  <admst:template match="af:print:expression">
    <admst:choose>
      <admst:when test="caller()/template/textmatch[value='af:print' or value='af:print:derivate']">
        <admst:apply-templates select="." match="af:print:expression">
          <admst:variable name="expression" string="%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
            <admst:variable name="dx_%(name)" string="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
        <admst:return name="x" string="$expression"/>
        <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
          <admst:return name="dx.%(name)" string="$(dx_%(name))"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[datatypename='probe']">
        <admst:fatal format="probe not allowed inside analog functions\n"/>
      </admst:when>
      <admst:when test="[datatypename='variable']">
        <admst:variable name="variable" string="%(name)"/>
        <admst:return name="x" string="$variable"/>
        <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
          <admst:variable name="ddx" string="%(name)"/>
          <admst:choose>
            <admst:when test="[$variable='$ddx']">
              <admst:return name="dx.$ddx" string="1.0"/>
            </admst:when>
            <admst:when test="../../prototype[functionpscope='input' or functionpscope='inout']">
              <admst:return name="dx.$ddx" string="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:return name="dx.$ddx" string="$(variable)_$ddx"/>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='unary')]">
        <admst:variable test="[name='plus']" name="op" string="+"/>
        <admst:variable test="[name='minus']" name="op" string="-"/>
        <admst:variable test="[name='not']" name="op" string="!"/>
        <admst:variable test="[name='bw_not']" name="op" string="~"/>
        <admst:apply-templates select="arguments[1]" match="af:print:expression">
          <admst:variable name="arg1" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:return name="x" string="($op$arg1)"/>
        <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
          <admst:return name="dx.%(name)" string="0.0"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='binary')]">
        <admst:apply-templates select="arguments[1]" match="af:print:expression">
          <admst:variable name="x" string="%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
            <admst:variable name="dx_%(name)" string="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
        <admst:apply-templates select="arguments[2]" match="af:print:expression">
          <admst:variable name="y" string="%(returned('x')/value)"/>
          <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
            <admst:variable name="dy_%(name)" string="%(returned('dx.%(name)')/value)"/>
          </admst:for-each>
        </admst:apply-templates>
        <admst:choose>
          <admst:when test="[name='addp']">
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="x" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:return name="x" string="(+$y)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:return name="x" string="$x"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="x" string="($x+$y)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="df" path="name"/>
              <admst:choose>
                <admst:when test="[$x='0.0' and $y='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:when test="[$x='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="$(dy_$df)"/>
                </admst:when>
                <admst:when test="[$y='0.0']">
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="$(dy_$df)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$dx='0.0' and $dy='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$dx='0.0']">
                  <admst:return name="dx.$df" string="(+$dy)"/>
                </admst:when>
                <admst:when test="[$dy='0.0']">
                  <admst:return name="dx.$df" string="$dx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:return name="dx.$df" string="($dx+$dy)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
          </admst:when>
          <admst:when test="[name='addm']">
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:return name="x" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='0.0']">
                <admst:return name="x" string="(-$y)"/>
              </admst:when>
              <admst:when test="[$y='0.0']">
                <admst:return name="x" string="$x"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="x" string="($x-$y)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="df" path="name"/>
              <admst:choose>
                <admst:when test="[$x='0.0' and $y='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:when test="[$x='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="$(dy_$df)"/>
                </admst:when>
                <admst:when test="[$y='0.0']">
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="$(dy_$df)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$dx='0.0' and $dy='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$dx='0.0']">
                  <admst:return name="dx.$df" string="(-$dy)"/>
                </admst:when>
                <admst:when test="[$dy='0.0']">
                  <admst:return name="dx.$df" string="$dx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:return name="dx.$df" string="($dx-$dy)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
          </admst:when>
          <admst:when test="[name='multtime']">
            <admst:choose>
              <admst:when test="[$x='0.0' or $y='0.0']">
                <admst:return name="x" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:return name="x" string="1.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="x" string="($x*$y)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="df" path="name"/>
              <admst:choose>
                <admst:when test="[$x='0.0' or $y='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:when test="[$x='1.0' and $y='1.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="$(dy_$df)"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$x='0.0' and $y='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$dx='0.0' and $dy='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$dx='0.0' and $dy='1.0']">
                  <admst:return name="dx.$df" string="($x)"/>
                </admst:when>
                <admst:when test="[$dx='1.0' and $dy='0.0']">
                  <admst:return name="dx.$df" string="($y)"/>
                </admst:when>
                <admst:when test="[$dx='0.0']">
                  <admst:return name="dx.$df" string="($x*$dy)"/>
                </admst:when>
                <admst:when test="[$dy='0.0']">
                  <admst:return name="dx.$df" string="$dx*$y"/>
                </admst:when>
                <admst:when test="[$dx='1.0' and $dy='1.0']">
                  <admst:return name="dx.$df" string="($x+$y)"/>
                </admst:when>
                <admst:when test="[$dx='1.0']">
                  <admst:return name="dx.$df" string="($y+($dy*$x))"/>
                </admst:when>
                <admst:when test="[$dy='1.0']">
                  <admst:return name="dx.$df" string="($dx*$y)+$x"/>
                </admst:when>
                <admst:when test="[$x='1.0']">
                  <admst:return name="dx.$df" string="$dy"/>
                </admst:when>
                <admst:when test="[$y='1.0']">
                  <admst:return name="dx.$df" string="$dx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:return name="dx.$df" string="(($dx*$y)+($x*$dy))"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
          </admst:when>
          <admst:when test="[name='multdiv']">
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:return name="x" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0' and $y='1.0']">
                <admst:return name="x" string="1.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:return name="x" string="($x/$y)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="df" path="name"/>
              <admst:choose>
                <admst:when test="[$x='0.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:when test="[$x='1.0' and $y='1.0']">
                  <admst:variable name="dx" string="0.0"/>
                  <admst:variable name="dy" string="0.0"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="dx" string="$(dx_$df)"/>
                  <admst:variable name="dy" string="$(dy_$(df))"/>
                </admst:otherwise>
              </admst:choose>
              <admst:choose>
                <admst:when test="[$x='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$dx='0.0' and $dy='0.0']">
                  <admst:return name="dx.$df" string="0.0"/>
                </admst:when>
                <admst:when test="[$x='1.0']">
                  <admst:choose>
                    <admst:when test="[$dy='1.0']">
                      <admst:return name="dx.$df" string="(-1/($y*$y))"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:return name="dx.$df" string="(-$dy/($y*$y))"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$dx='0.0']">
                  <admst:choose>
                    <admst:when test="[$dy='1.0']">
                      <admst:return name="dx.$df" string="(-$x/($y*$y))"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:return name="dx.$df" string="(-($x*$dy)/($y*$y))"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:when test="[$dx='1.0']">
                  <admst:choose>
                    <admst:when test="[$dy='0.0']">
                      <admst:return name="dx.$df" string="(1/$y)"/>
                    </admst:when>
                    <admst:when test="[$dy='1.0']">
                      <admst:return name="dx.$df" string="(($y-$x)/($y*$y))"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:return name="dx.$df" string="(($y-($x*$dy))/($y*$y))"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:when>
                <admst:otherwise>
                  <admst:choose>
                    <admst:when test="[$y='1.0']">
                      <admst:return name="dx.$df" string="$dx"/>
                    </admst:when>
                    <admst:when test="[$dy='0.0']">
                      <admst:return name="dx.$df" string="$dx/$y"/>
                    </admst:when>
                    <admst:when test="[$dy='1.0']">
                      <admst:return name="dx.$df" string="(($dx*$y)-$x)/($y*$y)"/>
                    </admst:when>
                    <admst:otherwise>
                      <admst:return name="dx.$df" string="($dx*$y-$x*$dy)/($y*$y)"/>
                    </admst:otherwise>
                  </admst:choose>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[name='bw_equr']">
                <admst:return name="x" string="($x^~$y)"/>
              </admst:when>
              <admst:when test="[name='bw_equl']">
                <admst:return name="x" string="($x~^$y)"/>
              </admst:when>
              <admst:when test="[name='bw_xor']">
                <admst:return name="x" string="($x^$y)"/>
              </admst:when>
              <admst:when test="[name='bw_or']">
                <admst:return name="x" string="($x|$y)"/>
              </admst:when>
              <admst:when test="[name='bw_and']">
                <admst:return name="x" string="($x&amp;$y)"/>
              </admst:when>
              <admst:when test="[name='or']">
                <admst:return name="x" string="($x||$y)"/>
              </admst:when>
              <admst:when test="[name='and']">
                <admst:return name="x" string="($x&amp;&amp;$y)"/>
              </admst:when>
              <admst:when test="[name='equ']">
                <admst:return name="x" string="($x==$y)"/>
              </admst:when>
              <admst:when test="[name='multmod']">
                <admst:return name="x" string="((int)$x%%(int)$y)"/>
              </admst:when>
              <admst:when test="[name='notequ']">
                <admst:return name="x" string="($x!=$y)"/>
              </admst:when>
              <admst:when test="[name='lt']">
                <admst:return name="x" string="($x&lt;$y)"/>
              </admst:when>
              <admst:when test="[name='lt_equ']">
                <admst:return name="x" string="($x&lt;=$y)"/>
              </admst:when>
              <admst:when test="[name='gt']">
                <admst:return name="x" string="($x&gt;$y)"/>
              </admst:when>
              <admst:when test="[name='gt_equ']">
                <admst:return name="x" string="($x&gt;=$y)"/>
              </admst:when>
              <admst:when test="[name='shiftr']">
                <admst:return name="x" string="($x&gt;&gt;$y)"/>
              </admst:when>
              <admst:when test="[name='shiftl']">
                <admst:return name="x" string="($x&lt;&lt;$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:error format="%(name):function not handled\n"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:return name="dx.%(name)" string="0.0"/>
            </admst:for-each>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[(datatypename='function' and arity='ternary')]">
        <admst:apply-templates select="arguments[1]" match="af:print:expression">
          <admst:variable name="x" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="arguments[2]" match="af:print:expression">
          <admst:variable name="y" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="arguments[3]" match="af:print:expression">
          <admst:variable name="z" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:if test="[name='conditional']">
          <admst:return name="x" string="($x?$y:$z)"/>
          <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
            <admst:return name="dx.%(name)" string="($x?$dy_%(name):$dz_%(name))"/>
          </admst:for-each>
        </admst:if>
      </admst:when>
      <admst:when test="[datatypename='function']">
        <admst:variable name="function" string="%(fgetname(.)/[name='fgetname']/value)"/>
        <admst:variable name="args" string=""/>
        <admst:for-each select="arguments">
          <admst:variable test="[not($args='')]" name="args" string="$args,"/>
          <admst:apply-templates select="." match="af:print:expression">
            <admst:variable name="index" string="%(index(../arguments,.))"/>
            <admst:variable name="args" string="$args%(returned('x')/value)"/>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="arg$(index)_%(name)" string="%(returned('dx.%(name)')/value)"/>
            </admst:for-each>
          </admst:apply-templates>
        </admst:for-each>
        <admst:choose>
          <admst:when test="[ name='cos' or name='sin' or name='tan' or name='cosh' or name='sinh' or name='tanh' or name='acos' or name='asin'                             or name='atan' or name='ln' or name='log' or name='exp' or name='sqrt' or name='abs' or name='limexp'                             or name='div' or name='pow' or name='hypot' or name='min' or name='max' or name='\$vt' ]">
            <admst:return name="x" string="_$function($args)"/>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="name" path="name"/>
              <admst:variable name="ret" string=""/>
              <admst:for-each select="../../arguments">
                <admst:variable test="[not($ret='')]" name="ret" string="$ret+"/>
                <admst:variable name="index" string="%(index(../arguments,.))"/>
                <admst:variable name="ret" string="$(ret)_d$(index)_$function($args)*($(arg$(index)_$name))"/>
              </admst:for-each>
              <admst:return name="dx.$name" string="$ret"/>
            </admst:for-each>
          </admst:when>
          <admst:otherwise>
            <admst:return name="x" string="$(module)_$function($args)"/>
            <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
              <admst:variable name="name" path="name"/>
              <admst:variable name="darg" string=""/>
              <admst:for-each select="../../arguments">
                <admst:variable name="index" string="%(index(../arguments,.))"/>
                <admst:variable name="darg" string="$darg,($(arg$(index)_$name))"/>
              </admst:for-each>
              <admst:return name="dx.$name" string="$(module)_d_$function($args$darg)"/>
            </admst:for-each>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='string']">
        <admst:return name="x" string="&quot;%(value)&quot;"/>
        <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
          <admst:return name="dx.%(name)" string="0.0"/>
        </admst:for-each>
      </admst:when>
      <admst:when test="[datatypename='number']">
        <admst:choose>
          <admst:when test="[scalingunit='1']">
            <admst:return name="x" string="%(value)"/>
          </admst:when>
          <admst:when test="[scalingunit='E']">
            <admst:return name="x" string="(%(value)*1.0e+18)"/>
          </admst:when>
          <admst:when test="[scalingunit='P']">
            <admst:return name="x" string="(%(value)*1.0e+15)"/>
          </admst:when>
          <admst:when test="[scalingunit='T']">
            <admst:return name="x" string="(%(value)*1.0e+12)"/>
          </admst:when>
          <admst:when test="[scalingunit='G']">
            <admst:return name="x" string="(%(value)*1.0e+9)"/>
          </admst:when>
          <admst:when test="[scalingunit='M']">
            <admst:return name="x" string="(%(value)*1.0e+6)"/>
          </admst:when>
          <admst:when test="[scalingunit='k']">
            <admst:return name="x" string="(%(value)*1.0e+3)"/>
          </admst:when>
          <admst:when test="[scalingunit='h']">
            <admst:return name="x" string="(%(value)*1.0e+2)"/>
          </admst:when>
          <admst:when test="[scalingunit='D']">
            <admst:return name="x" string="(%(value)*1.0e+1)"/>
          </admst:when>
          <admst:when test="[scalingunit='d']">
            <admst:return name="x" string="(%(value)*1.0e-1)"/>
          </admst:when>
          <admst:when test="[scalingunit='c']">
            <admst:return name="x" string="(%(value)*1.0e-2)"/>
          </admst:when>
          <admst:when test="[scalingunit='m']">
            <admst:return name="x" string="(%(value)*1.0e-3)"/>
          </admst:when>
          <admst:when test="[scalingunit='u']">
            <admst:return name="x" string="(%(value)*1.0e-6)"/>
          </admst:when>
          <admst:when test="[scalingunit='n']">
            <admst:return name="x" string="(%(value)*1.0e-9)"/>
          </admst:when>
          <admst:when test="[scalingunit='A']">
            <admst:return name="x" string="(%(value)*1.0e-10)"/>
          </admst:when>
          <admst:when test="[scalingunit='p']">
            <admst:return name="x" string="(%(value)*1.0e-12)"/>
          </admst:when>
          <admst:when test="[scalingunit='f']">
            <admst:return name="x" string="(%(value)*1.0e-15)"/>
          </admst:when>
          <admst:when test="[scalingunit='a']">
            <admst:return name="x" string="(%(value)*1.0e-18)"/>
          </admst:when>
          <admst:otherwise>
            <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
          <admst:return name="dx.%(name)" string="0.0"/>
        </admst:for-each>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): not handled inside expression\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="af:print">
    <admst:choose>
      <admst:when test="[datatypename='function' and arity='callfunction']">
        <admst:choose>
          <admst:when test="[name='\$strobe']">
            <admst:variable name="outputfile" string="stdout"/>
          </admst:when>
        </admst:choose>
        <admst:variable name="args" string=""/>
        <admst:for-each select="arguments">
          <admst:apply-templates select="." match="af:print:expression">
            <admst:variable name="index" string="%(index(../arguments,.))"/>
            <admst:variable name="args" string="$args,%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whilecode" match="af:print:expression">
          <admst:variable name="whilecode" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="whilecondition" match="af:print">
          <admst:variable name="while" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:return name="x" string="while($whilecode)\n$while"/>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="ifcondition" match="af:print:expression">
          <admst:variable name="if" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="thencode" match="af:print">
          <admst:variable name="then" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:if test="[exists(elsecode)]">
          <admst:apply-templates select="elsecode" match="af:print">
            <admst:variable name="then" string="$(then)else\n%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:if>
        <admst:return name="x" string="if($if)\n$then"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="casecondition" match="af:print:expression">
          <admst:variable name="case" string="switch ((int)%(returned('x')/value)) {\n"/>
        </admst:apply-templates>
        <admst:for-each select="caseitem">
          <admst:variable name="casealternative" string=""/>
          <admst:for-each select="casealternative">
            <admst:variable name="casealternative" string="$condition case %(.):"/>
          </admst:for-each>
          <admst:variable name="case" string="$case $condition"/>
          <admst:variable test="[defaultcase='yes']" name="case" string="$case default:"/>
          <admst:variable name="case" string="$case \n"/>
          <admst:apply-templates select="casecode" match="af:print">
            <admst:variable name="case" string="$case%(returned('x')/value) break;\n"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="$case }"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:fatal format="contribution not allowed inside analog functions\n"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:apply-templates select="rhs" match="af:print:expression">
          <admst:return name="x" string="%(../lhs/name)=%(returned('x')/value);\n"/>
        </admst:apply-templates>
      </admst:when>
      <admst:when test="[datatypename='nilled']">
        <admst:return name="x" string=";"/>
      </admst:when>
      <admst:when test="[datatypename='block']">
        <admst:variable name="block" string=""/>
        <admst:for-each select="blockcode">
          <admst:apply-templates select="." match="af:print">
            <admst:variable name="block" string="$block%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="{$block}"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="af:print:derivate">
    <admst:choose>
      <admst:when test="[datatypename='function' and arity='callfunction']">
        <admst:choose>
          <admst:when test="[name='\$strobe']">
            <admst:variable name="outputfile" string="stdout"/>
          </admst:when>
        </admst:choose>
        <admst:variable name="args" string=""/>
        <admst:for-each select="arguments">
          <admst:apply-templates select="." match="af:print:expression">
            <admst:variable name="index" string="%(index(../arguments,.))"/>
            <admst:variable name="args" string="$args,%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="fprintf($outputfile$args); fprintf($outputfile,&quot;\n&quot;);\n"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whilecode" match="af:print:expression">
          <admst:variable name="whilecode" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="whilecondition" match="af:print:derivate">
          <admst:variable name="while" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:return name="x" string="while($whilecode)\n$while"/>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="ifcondition" match="af:print:expression">
          <admst:variable name="if" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:apply-templates select="thencode" match="af:print:derivate">
          <admst:variable name="then" string="%(returned('x')/value)"/>
        </admst:apply-templates>
        <admst:if test="[exists(elsecode)]">
          <admst:apply-templates select="elsecode" match="af:print:derivate">
            <admst:variable name="then" string="$(then)else\n%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:if>
        <admst:return name="x" string="if($if)\n$then"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="casecondition" match="af:print:expression">
          <admst:variable name="case" string="switch ((int)%(returned('x')/value)) {\n"/>
        </admst:apply-templates>
        <admst:for-each select="caseitem">
          <admst:variable name="casealternative" string=""/>
          <admst:for-each select="casealternative">
            <admst:variable name="casealternative" string="$condition case %(.):"/>
          </admst:for-each>
          <admst:variable name="case" string="$case $condition"/>
          <admst:variable test="[defaultcase='yes']" name="case" string="$case default:"/>
          <admst:variable name="case" string="$case \n"/>
          <admst:apply-templates select="casecode" match="af:print:derivate">
            <admst:variable name="case" string="$case%(returned('x')/value) break;\n"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="$case }"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:fatal format="contribution not allowed inside analog functions\n"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:variable name="lhs" string="%(lhs/name)"/>
        <admst:apply-templates select="rhs" match="af:print:expression">
          <admst:variable name="rhs" string=""/>
          <admst:for-each select="$globalanalogfunction/functionpvariable[functionpscope='input' or functionpscope='inout']">
            <admst:variable name="rhs" string="$rhs$(lhs)_%(name)=%(returned('dx.%(name)')/value);\n"/>
          </admst:for-each>
          <admst:variable name="rhs" string="$rhs$lhs=%(returned('x')/value);\n"/>
        </admst:apply-templates>
        <admst:return name="x" string="{$rhs}\n"/>
      </admst:when>
      <admst:when test="[datatypename='nilled']">
        <admst:return name="x" string=";"/>
      </admst:when>
      <admst:when test="[datatypename='block']">
        <admst:variable name="block" string=""/>
        <admst:for-each select="blockcode">
          <admst:apply-templates select="." match="af:print:derivate">
            <admst:variable name="block" string="$block%(returned('x')/value)"/>
          </admst:apply-templates>
        </admst:for-each>
        <admst:return name="x" string="{$block}"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="%(datatypename): not handled inside blocks\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="v2c:converttype">
    <admst:choose>
      <admst:when test="[type='integer']">
        <admst:text format="int"/>
      </admst:when>
      <admst:when test="[type='real']">
        <admst:text format="double"/>
      </admst:when>
      <admst:when test="[type='string']">
        <admst:text format="char*"/>
      </admst:when>
      <admst:otherwise>
        <admst:fatal format="should not be reached\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="fgetname">
    <admst:choose>
      <admst:when test="[name='abs']">
        <admst:return name="fgetname" string="fabs"/>
      </admst:when>
      <admst:when test="[name='\$shrinkl']">
        <admst:return name="fgetname" string="shrinkl"/>
      </admst:when>
      <admst:when test="[name='\$shrinka']">
        <admst:return name="fgetname" string="shrinka"/>
      </admst:when>
      <admst:when test="[name='log']">
        <admst:return name="fgetname" string="log10"/>
      </admst:when>
      <admst:when test="[name='ln']">
        <admst:return name="fgetname" string="logE"/>
      </admst:when>
      <admst:when test="[name='limexp']">
        <admst:return name="fgetname" string="limexp"/>
      </admst:when>
      <admst:when test="[name='\$limexp']">
        <admst:return name="fgetname" string="limexp"/>
      </admst:when>
      <admst:when test="[name='\$vt']">
        <admst:return name="fgetname" string="vt"/>
      </admst:when>
      <admst:when test="[name='\$model']">
        <admst:return name="fgetname" string="_modelname"/>
      </admst:when>
      <admst:when test="[name='\$instance']">
        <admst:return name="fgetname" string="_instancename"/>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:return name="fgetname" string="_circuit_temp"/>
      </admst:when>
      <admst:when test="[name='\$nominal_temperature']">
        <admst:return name="fgetname" string="_circuit_tnom"/>
      </admst:when>
      <admst:otherwise>
        <admst:return name="fgetname" string="%(name)"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="afgetname">
    <admst:choose>
      <admst:when test="[name='abs']">
        <admst:return name="afgetname" string="fabs"/>
      </admst:when>
      <admst:when test="[name='\$shrinkl']">
        <admst:return name="afgetname" string="shrinkl"/>
      </admst:when>
      <admst:when test="[name='\$shrinka']">
        <admst:return name="afgetname" string="shrinka"/>
      </admst:when>
      <admst:when test="[name='log']">
        <admst:return name="afgetname" string="log10"/>
      </admst:when>
      <admst:when test="[name='ln']">
        <admst:return name="afgetname" string="logE"/>
      </admst:when>
      <admst:when test="[name='limexp']">
        <admst:return name="afgetname" string="limexp"/>
      </admst:when>
      <admst:when test="[name='\$limexp']">
        <admst:return name="afgetname" string="limexp"/>
      </admst:when>
      <admst:when test="[name='\$model']">
        <admst:return name="afgetname" string="_modelname"/>
      </admst:when>
      <admst:when test="[name='\$instance']">
        <admst:return name="afgetname" string="_instancename"/>
      </admst:when>
      <admst:when test="[name='\$temperature']">
        <admst:return name="afgetname" string="_circuit_temp"/>
      </admst:when>
      <admst:when test="[name='\$nominal_temperature']">
        <admst:return name="afgetname" string="_circuit_tnom"/>
      </admst:when>
      <admst:otherwise>
        <admst:return name="afgetname" string="%(name)"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:template match="estringifynoprobe">
    <admst:apply-templates select="." match="subexpression:differentiate"/>
    <admst:return name="ret" string="$ztmp"/>
  </admst:template>
  <!-- expression//number -->
  <admst:template match="number">
    <admst:choose>
      <admst:when test="[scalingunit='1']">
        <admst:variable name="ztmp" string="%(value)"/>
      </admst:when>
      <admst:when test="[scalingunit='E']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+18)"/>
      </admst:when>
      <admst:when test="[scalingunit='P']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+15)"/>
      </admst:when>
      <admst:when test="[scalingunit='T']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+12)"/>
      </admst:when>
      <admst:when test="[scalingunit='G']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+9)"/>
      </admst:when>
      <admst:when test="[scalingunit='M']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+6)"/>
      </admst:when>
      <admst:when test="[scalingunit='k']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+3)"/>
      </admst:when>
      <admst:when test="[scalingunit='h']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+2)"/>
      </admst:when>
      <admst:when test="[scalingunit='D']">
        <admst:variable name="ztmp" string="(%(value)*1.0e+1)"/>
      </admst:when>
      <admst:when test="[scalingunit='d']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-1)"/>
      </admst:when>
      <admst:when test="[scalingunit='c']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-2)"/>
      </admst:when>
      <admst:when test="[scalingunit='m']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-3)"/>
      </admst:when>
      <admst:when test="[scalingunit='u']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-6)"/>
      </admst:when>
      <admst:when test="[scalingunit='n']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-9)"/>
      </admst:when>
      <admst:when test="[scalingunit='A']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-10)"/>
      </admst:when>
      <admst:when test="[scalingunit='p']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-12)"/>
      </admst:when>
      <admst:when test="[scalingunit='f']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-15)"/>
      </admst:when>
      <admst:when test="[scalingunit='a']">
        <admst:variable name="ztmp" string="(%(value)*1.0e-18)"/>
      </admst:when>
      <admst:otherwise>
        <admst:error format="scaling unit not supported: %(scalingunit)\n"/>
      </admst:otherwise>
    </admst:choose>
  </admst:template>
  <!-- global1 -->
  <admst:if test="[exists(/#simulator)]">
    <admst:variable name="globalmodule"/>
    <admst:variable name="globalassignment"/>
    <admst:variable name="globalcontribution"/>
    <admst:variable name="globalexpression"/>
    <admst:variable name="globalopdependent" string="no"/>
    <admst:variable name="globalpartitionning"/>
    <admst:variable name="globaltreenode"/>
    <admst:apply-templates select="." match="main"/>
  </admst:if>
  <!-- implicit -->
  <admst:if test="[/#simulator='ngspice']">
    <admst:message format="option --ngspice activated\n"/>
<?escript name="ngspice_1_0_1/ngspiceVersion.xml" ?>
    <admst:template match="e">
      <admst:apply-templates select="." match="hxx%(datatypename)">$e</admst:apply-templates>
    </admst:template>
    <admst:template match="ddx">
      <admst:apply-templates select="." match="hxx%(datatypename)"/>
    </admst:template>
    <admst:variable name="ddxinsidederivate" string="no"/>
    <admst:variable name="requiredderivateforddx" string="no"/>
    <admst:variable name="SkipFVariable" string="n"/>
    <admst:variable name="ngspicefile"/>
    <admst:template match="subexpression:differentiate">
      <admst:apply-templates select="." match="%(datatypename)"/>
      <admst:if test="$zprobe">
        <admst:choose>
          <admst:when test="[datatypename='probe']">
            <admst:choose>
              <admst:when test="[$zprobe/nature=nature and $zprobe/pnode=pnode and $zprobe/nnode=nnode]">
                <admst:variable name="zddx" string="1.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="0.0"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[datatypename='variable']">
            <admst:variable test="prototype[nilled(@vpprobe[$zprobe/nature=nature and $zprobe/pnode=pnode and $zprobe/nnode=nnode])]" name="zddx" string="0.0"/>
            <admst:if test="prototype/@vpprobe[$zprobe/nature=nature and $zprobe/pnode=pnode and $zprobe/nnode=nnode]">
              <admst:choose>
                <admst:when test="prototype[#insource=1]">
                  <admst:variable name="zddx" string="%(name)_%($zprobe/nature/access)%($zprobe/pnode/name)_%($zprobe/nnode/name)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="zddx" string="0.0"/>
                </admst:otherwise>
              </admst:choose>
            </admst:if>
          </admst:when>
          <admst:when test="[datatypename='number' or datatypename='variable']">
            <admst:variable name="zddx" string="0.0"/>
          </admst:when>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- unary-->
    <admst:template match="unary">
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="ztmp" string="(+%(estringifynoprobe(arguments[1])/[name='ret']/value))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="ztmp" string="(-%(estringifynoprobe(arguments[1])/[name='ret']/value))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="ztmp" string="(!%(estringifynoprobe(arguments[1])/[name='ret']/value))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="ztmp" string="(~%(estringifynoprobe(arguments[1])/[name='ret']/value))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(name):function not handled\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$zprobe">
        <admst:choose>
          <admst:when test="[$ztmp='0.0']">
            <admst:variable name="zddx" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[name='plus']">
                <admst:choose>
                  <admst:when test="[$zddx!='0.0']">
                    <admst:variable name="zddx" string="(+$zddx)"/>
                  </admst:when>
                </admst:choose>
              </admst:when>
              <admst:when test="[name='minus']">
                <admst:choose>
                  <admst:when test="[$zddx!='0.0']">
                    <admst:variable name="zddx" string="(-$zddx)"/>
                  </admst:when>
                </admst:choose>
              </admst:when>
              <admst:when test="[name='not']">
                <admst:choose>
                  <admst:when test="[$zddx!='0.0']">
                    <admst:variable name="zddx" string="(!$zddx)"/>
                  </admst:when>
                </admst:choose>
              </admst:when>
              <admst:when test="[name='bw_not']">
                <admst:choose>
                  <admst:when test="[$zddx!='0.0']">
                    <admst:variable name="zddx" string="(~$zddx)"/>
                  </admst:when>
                </admst:choose>
              </admst:when>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- binary !-->
    <admst:template match="binary">
      <admst:choose>
        <admst:when test="[name='bw_equr']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)^~%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='bw_equl']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)~^%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='bw_xor']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)^%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='bw_or']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)|%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='bw_and']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&amp;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='multmod']">
          <admst:apply-templates select="arguments[2]" match="estringifynoprobe"/>
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)%$ztmp)"/>
        </admst:when>
        <admst:when test="[name='or']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)||%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='and']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&amp;&amp;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='equ']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)==%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='notequ']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)!=%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='lt']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&lt;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='lt_equ']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&lt;=%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='gt']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&gt;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='gt_equ']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&gt;=%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='shiftr']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&gt;&gt;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='shiftl']">
          <admst:variable name="ztmp" string="(%(estringifynoprobe(arguments[1])/[name='ret']/value)&lt;&lt;%(estringifynoprobe(arguments[2])/[name='ret']/value))"/>
        </admst:when>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="x" string="%(estringifynoprobe(arguments[1])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dx" string="$zddx"/>
              <admst:variable name="y" string="%(estringifynoprobe(arguments[2])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dy" string="$zddx"/>
              <admst:variable name="ztmp" string="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="x" string="%(estringifynoprobe(arguments[1])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dx" string="$zddx"/>
              <admst:variable name="y" string="%(estringifynoprobe(arguments[2])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dy" string="$zddx"/>
              <admst:variable name="ztmp" string="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="x" string="%(estringifynoprobe(arguments[1])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dx" string="$zddx"/>
              <admst:apply-templates select="arguments[2]" match="estringifynoprobe"/>
              <admst:variable test="$zprobe" name="dy" string="$zddx"/>
              <admst:variable name="y" string="$ztmp"/>
              <admst:variable name="ztmp" string="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="x" string="%(estringifynoprobe(arguments[1])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dx" string="$zddx"/>
              <admst:variable name="y" string="%(estringifynoprobe(arguments[2])/[name='ret']/value)"/>
              <admst:variable test="$zprobe" name="dy" string="$zddx"/>
              <admst:variable name="ztmp" string="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(name):function not handled\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$zprobe">
        <admst:choose>
          <admst:when test="[name='addp']">
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="(+$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:variable name="zddx" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="($dx+$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='addm']">
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="(-$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:variable name="zddx" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="($dx-$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multtime']">
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='1.0']">
                <admst:variable name="zddx" string="($x)"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='0.0']">
                <admst:variable name="zddx" string="($y)"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="($x*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:variable name="zddx" string="$dx*$y"/>
              </admst:when>
              <admst:when test="[$dx='1.0' and $dy='1.0']">
                <admst:variable name="zddx" string="($x+$y)"/>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:variable name="zddx" string="($y+($dy*$x))"/>
              </admst:when>
              <admst:when test="[$dy='1.0']">
                <admst:variable name="zddx" string="($dx*$y)+$x"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:variable name="zddx" string="$dy"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:variable name="zddx" string="$dx"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="(($dx*$y)+($x*$dy))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multdiv']">
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:variable name="zddx" string="(-1/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="zddx" string="(-$dy/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:choose>
                  <admst:when test="[$dy='1.0']">
                    <admst:variable name="zddx" string="(-$x/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="zddx" string="(-($x*$dy)/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$dx='1.0']">
                <admst:choose>
                  <admst:when test="[$dy='0.0']">
                    <admst:variable name="zddx" string="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:variable name="zddx" string="(($y-$x)/($y*$y))"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="zddx" string="(($y-($x*$dy))/($y*$y))"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:variable name="zddx" string="$dx"/>
                  </admst:when>
                  <admst:when test="[$dy='0.0']">
                    <admst:variable name="zddx" string="$dx/$y"/>
                  </admst:when>
                  <admst:when test="[$dy='1.0']">
                    <admst:variable name="zddx" string="(($dx*$y)-$x)/($y*$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="zddx" string="($dx*$y-$x*$dy)/($y*$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="zddx" string=""/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- ternary-->
    <admst:template match="ternary">
      <admst:apply-templates select="arguments[3]" match="subexpression:differentiate"/>
      <admst:variable name="z" string="$ztmp"/>
      <admst:variable name="dz" string="$zddx"/>
      <admst:apply-templates select="arguments[2]" match="subexpression:differentiate"/>
      <admst:variable name="y" string="$ztmp"/>
      <admst:variable name="dy" string="$zddx"/>
      <admst:variable name="x" string="%(estringifynoprobe(arguments[1])/[name='ret']/value)"/>
      <admst:variable name="ztmp" string="($x?$y:$z)"/>
      <admst:variable test="$zprobe" name="zddx" string="($x?$dy:$dz)"/>
    </admst:template>
    <!-- functions-->
    <admst:template match="function:assert:noarg">
      <admst:if test="[exists(arguments)]">
        <admst:error format="%(name): should not have arguments\n"/>
      </admst:if>
    </admst:template>
    <admst:template match="function:assert:onearg">
      <admst:if test="[not(count(arguments)=1)]">
        <admst:error format="%(name): should have one argument exactly\n"/>
      </admst:if>
    </admst:template>
    <admst:template match="nary">
      <admst:apply-templates select="." match="function:def"/>
    </admst:template>
    <admst:template match="function:def">
      <admst:choose>
        <admst:when test="[name='ddt']">
          <admst:for-each select="arguments[1]">
            <admst:variable name="ztmp" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
          </admst:for-each>
        </admst:when>
        <admst:when test="[name='\$param_given']">
          <admst:for-each select="arguments[1]">
            <admst:error test="[datatypename!='variable']" format="\$given: argument is not a variable\n"/>
            <admst:error test="prototype[isparameter='no']" format="\$given(%(name)): argument is not a parameter\n"/>
            <admst:choose>
              <admst:when test="prototype[#parametertype!='instance']">
                <admst:variable name="ztmp" string="model-&gt;%(name)_Given"/>
              </admst:when>
              <admst:when test="prototype[#parametertype='instance']">
                <admst:variable name="ztmp" string="here-&gt;%(name)_Given"/>
              </admst:when>
              <admst:otherwise>
                <admst:error format="\$given(%(name)): should not be reached\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$model']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="%(fgetname(.)/[name='fgetname']/value)"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$instance']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="%(fgetname(.)/[name='fgetname']/value)"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$temperature']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="%(fgetname(.)/[name='fgetname']/value)"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$nominal_temperature']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="%(fgetname(.)/[name='fgetname']/value)"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$vt']">
          <admst:choose>
            <admst:when test="[exists(arguments)]">
              <admst:choose>
                <admst:when test="[count(arguments)=1]">
                  <admst:apply-templates select="." match="function:assert:onearg"/>
                  <admst:for-each select="arguments[1]">
                    <admst:variable name="ztmp" string="_vt(%(estringifynoprobe(.)/[name='ret']/value))"/>
                  </admst:for-each>
                </admst:when>
                <admst:otherwise>
                  <admst:error format="$vt(...): too many args"/>
                </admst:otherwise>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:apply-templates select="." match="function:assert:noarg"/>
              <admst:variable name="ztmp" string="_vt_nom"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$scale']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="_scale"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$abstime']">
          <admst:apply-templates select="." match="function:assert:noarg"/>
          <admst:variable name="ztmp" string="_abstime"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$options']">
          <admst:for-each select="arguments[1]">
            <admst:if test="[datatypename!='string']">
              <admst:error format="$given: argument is not a string\n"/>
            </admst:if>
            <admst:choose>
              <admst:when test="[value='OPTm_hier']">
                <admst:variable name="ztmp" string="_circuit_m_hier"/>
              </admst:when>
              <admst:otherwise>
                <admst:fatal format="$options(%(value)): bad argument []\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:for-each>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='ddx']">
          <admst:error test="arguments[1]/[datatypename!='variable']" format="%(../name): first argument is not a variable\n"/>
          <admst:error test="arguments[2]/[datatypename!='probe']" format="%(../name): second argument is not a probe\n"/>
          <admst:variable name="ztmp" string="%(arguments[1]/name)_%(arguments[2]/nature/access)%(arguments[2]/pnode/name)_%(arguments[2]/nnode/name)"/>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='floor']">
          <admst:apply-templates select="." match="function:assert:onearg"/>
          <admst:for-each select="arguments[1]">
            <admst:variable name="ztmp" string="floor(%(estringifynoprobe(.)/[name='ret']/value))"/>
          </admst:for-each>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='ceil']">
          <admst:apply-templates select="." match="function:assert:onearg"/>
          <admst:for-each select="arguments[1]">
            <admst:variable name="ztmp" string="ceil(%(estringifynoprobe(.)/[name='ret']/value))"/>
          </admst:for-each>
          <admst:variable test="$zprobe" name="zddx" string="0.0"/>
        </admst:when>
        <admst:when test="[name='\$simparam']">
          <admst:fatal format="function:simparam"/>
          <admst:apply-templates select="." match="function:simparam"/>
        </admst:when>
        <admst:when test="[name='pow' or name='hypot' or name='min' or name='max']">
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:if test="$zprobe">
            <admst:for-each select="arguments">
              <admst:choose>
                <admst:when test="[position()=1]">
                  <admst:variable name="x" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dx" string="$zddx"/>
                </admst:when>
                <admst:when test="[position()=2]">
                  <admst:variable name="y" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dy" string="$zddx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:error format="%(../name)(...): two arguments expected - %(count(../arguments)) found(s) \n"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="(__dFy_%(name)_$index*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:variable name="zddx" string="(__dFx_%(name)_$index*$dx)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="(__dFx_%(fgetname(.)/[name='fgetname']/value)_$index*$dx+__dFy_%(fgetname(.)/[name='fgetname']/value)_$index*$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
          <admst:variable name="args" string=""/>
          <admst:for-each select="arguments">
            <admst:variable test="[$args!='']" name="args" string="$args,"/>
            <admst:variable name="e" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
            <admst:variable name="args" string="$args$e"/>
          </admst:for-each>
          <admst:variable name="ztmp" string="%(fgetname(.)/[name='fgetname']/value)($args)"/>
        </admst:when>
        <admst:when test="[name='div']">
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:if test="$zprobe">
            <admst:for-each select="arguments">
              <admst:choose>
                <admst:when test="[position()=1]">
                  <admst:variable name="x" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dx" string="$zddx"/>
                </admst:when>
                <admst:when test="[position()=2]">
                  <admst:variable name="y" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dy" string="$zddx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:error format="%(../name)(...): two arguments expected - %(count(../arguments)) found(s) \n"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
            <admst:choose>
              <admst:when test="[$dx='0.0' and $dy='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="(__dFy_%(name)_$index*$dy)"/>
              </admst:when>
              <admst:when test="[$dy='0.0']">
                <admst:variable name="zddx" string="(__dFx_%(name)_$index*$dx)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="(__dFx_%(name)_$index*$dx+__dFy_%(name)_$index*$dy)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
          <admst:variable name="ztmp" string="__%(fgetname(.)/[name='fgetname']/value)_$index"/>
        </admst:when>
        <admst:when test="[#class='builtin']">
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:if test="$zprobe">
            <admst:error test="[#class!='builtin']" format="%(name)(...): functionp not supported\n"/>
            <admst:for-each select="arguments">
              <admst:choose>
                <admst:when test="[position()=1]">
                  <admst:variable name="x" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dx" string="$zddx"/>
                </admst:when>
                <admst:otherwise>
                  <admst:error test="[#class='builtin']" format="%(../name)(...): one argument expected - %(count(../arguments)) found(s) \n"/>
                </admst:otherwise>
              </admst:choose>
            </admst:for-each>
            <admst:choose>
              <admst:when test="[$dx='0.0']">
                <admst:variable name="zddx" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="zddx" string="$dx*__d_%(fgetname(.)/[name='fgetname']/value)_$index"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
          <admst:variable name="ztmp" string="__%(fgetname(.)/[name='fgetname']/value)_$index"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='analysis']">
              <admst:apply-templates select="." match="function:analysis"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="function" string="%(funcname(.)/[name='fname']/value)"/>
              <admst:variable name="args" string=""/>
              <admst:for-each select="arguments">
                <admst:variable name="index" string="%(position())"/>
                <admst:variable test="[not($args='')]" name="args" string="$args,"/>
                <admst:variable name="arg$index" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                <admst:variable name="args" string="$args$(arg$index)"/>
              </admst:for-each>
              <admst:variable name="ztmp" string="$function($args)"/>
              <admst:if test="$zprobe">
                <admst:variable name="dargs" string="$args"/>
                <admst:for-each select="arguments">
                  <admst:variable name="x" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
                  <admst:variable name="dargs" string="$dargs,$zddx"/>
                </admst:for-each>
                <admst:variable name="zddx" string="d_$function($dargs)"/>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="function:analysis">
      <admst:variable name="function" string="%(name)"/>
      <admst:variable name="args" string=""/>
      <admst:for-each select="arguments">
        <admst:variable name="index" string="%(position())"/>
        <admst:variable test="[not($args='')]" name="args" string="$args,"/>
        <admst:variable name="arg$index" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
        <admst:variable name="args" string="$args$(arg$index)"/>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[$arg1='&quot;noise&quot;']">
          <admst:variable name="ztmp" string="0.0"/>
          <admst:error format="$function($args): replaced by 0.0\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="function:simparam">
      <admst:variable name="function" string="%(name)"/>
      <admst:variable name="args" string=""/>
      <admst:for-each select="arguments">
        <admst:variable name="index" string="%(position())"/>
        <admst:variable test="[not($args='')]" name="args" string="$args,"/>
        <admst:variable name="arg$index" string="%(estringifynoprobe(.)/[name='ret']/value)"/>
        <admst:variable name="args" string="$args$(arg$index)"/>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[$arg1='&quot;gdev&quot;']">
          <admst:variable name="ztmp" string="_circuit_gdev"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;gmin&quot;']">
          <admst:variable name="ztmp" string="_circuit_gmin"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;imax&quot;']">
          <admst:variable name="ztmp" string="_circuit_imax"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;imelt&quot;']">
          <admst:variable name="ztmp" string="_circuit_imelt"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;iteration&quot;']">
          <admst:variable name="ztmp" string="_circuit_iteration"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;scale&quot;']">
          <admst:variable name="ztmp" string="_circuit_scale"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;shrink&quot;']">
          <admst:variable name="ztmp" string="_circuit_shrink"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;simulatorSubversion&quot;']">
          <admst:variable name="ztmp" string="_circuit_simulatorSubversion"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;simulatorVersion&quot;']">
          <admst:variable name="ztmp" string="_circuit_simulatorVersion"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;sourceScaleFactor&quot;']">
          <admst:variable name="ztmp" string="_circuit_sourceScaleFactor"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;tnom&quot;']">
          <admst:variable name="ztmp" string="_circuit_tnom"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;checkjcap&quot;']">
          <admst:variable name="ztmp" string="1.0"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;maxmosl&quot;']">
          <admst:variable name="ztmp" string="1.0"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;maxmosw&quot;']">
          <admst:variable name="ztmp" string="1.0"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;minmosl&quot;']">
          <admst:variable name="ztmp" string="1.0e-12"/>
        </admst:when>
        <admst:when test="[$arg1='&quot;minmosw&quot;']">
          <admst:variable name="ztmp" string="1.0e-12"/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="$function($args) -- not implemented in ngspice interface\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="variable:declaration1">
      <admst:for-each select="#module/@variable">
        <admst:assert test="[datatypename='variable']" format="expecting datatypename=variable\n"/>
        <admst:if test="prototype[(#scope!='global_model' and #scope!='global_instance')]">
          <admst:if test="prototype[not(#modifys=1 or #modifyfn=1 or #modifywn=1 or #modifyc=1) and #modifyd=1]">#if defined(_DYNAMIC)\n</admst:if>
          <admst:if test="prototype[type='integer']">int %(name);\n</admst:if>
          <admst:if test="prototype[type='real']">double %(name)=0.0/0.0;\n</admst:if>
          <admst:if test="prototype[type='string']">char* %(name);\n</admst:if>
          <admst:if test="prototype[#insource=1]">
            <admst:if test="prototype/@vpprobe">
              <admst:text format="#if defined(_DERIVATE)\n"/>
              <admst:text select="prototype/@vpprobe" format="double %(../name)_%(nature/access)%(pnode/name)_%(nnode/name)=0.0;\n"/>
              <admst:text format="#endif /*_DERIVATE*/\n"/>
            </admst:if>
          </admst:if>
          <admst:if test="prototype[not(#modifys=1 or #modifyfn=1 or #modifywn=1 or #modifyc=1) and #modifyd=1]">#endif /*_DYNAMIC*/\n</admst:if>
        </admst:if>
        <admst:if test="prototype[(#scope='global_model' or #scope='global_instance') and #insource=1 and exists(@vpprobe)]">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:text select="prototype/@vpprobe" format="double %(../name)_%(nature/access)%(pnode/name)_%(nnode/name)=0.0;\n"/>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:for-each>
      <admst:value-to select="#module/@variable"/>
    </admst:template>
    <!-- save all variables used for local declaration -->
    <!-- modulecode//block -->
    <admst:template match="block">
      <admst:assert test="[name!='/']" format="expecting subblock\n"/>
      <admst:text format="{\n"/>
      <admst:for-each select="blockvariablep">
        <admst:if test="[type='integer']">int %(name);\n</admst:if>
        <admst:if test="[type='real']">double %(name);\n</admst:if>
        <admst:if test="[type='string']">char* %(name);\n</admst:if>
        <admst:text test="[#insource=1]" select="@vpprobe" format="double %(../name)_%(nature/access)%(pnode/name)_%(nnode/name);\n"/>
      </admst:for-each>
      <admst:for-each select="blockcode">
        <admst:apply-templates select="." match="%(datatypename)"/>
      </admst:for-each>
      <admst:text format="}\n"/>
    </admst:template>
    <!-- modulecode/[initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
    <admst:template match="block:initial">
      <admst:assert test="[datatypename='block']" format="expecting datatypename=block\n"/>
      <admst:apply-templates select="." match="block:local:declaration"/>
      <admst:apply-templates select="." match="variable:declaration1"/>
      <admst:apply-templates select="." match="block"/>
    </admst:template>
    <admst:template match="modulecode:initial_instance">
        <admst:if test="[datatypename='block']">
          <admst:for-each select="blockcode">
            <admst:apply-templates select="[datatypename='block' and (name='initial_instance' or name='initializeInstance')]" match="block:initial"/>
          </admst:for-each>
        </admst:if>
    </admst:template>
    <admst:template match="modulecode:initial_model">
        <admst:if test="[datatypename='block']">
          <admst:for-each select="blockcode">
            <admst:apply-templates select="[datatypename='block' and (name='initial_model' or name='initializeModel')]" match="block:initial"/>
          </admst:for-each>
        </admst:if>
    </admst:template>
    <admst:template match="modulecode:initial_step">
        <admst:if test="[datatypename='block']">
          <admst:for-each select="blockcode">
            <admst:apply-templates select="[datatypename='block' and name='initial_step']" match="block:initial"/>
          </admst:for-each>
        </admst:if>
    </admst:template>
    <admst:template match="modulecode:noise">
        <admst:if test="[datatypename='block']">
          <admst:for-each select="blockcode">
            <admst:if test="[datatypename='block']">
              <admst:apply-templates select="[name='noise']" match="block:initial"/>
            </admst:if>
          </admst:for-each>
        </admst:if>
    </admst:template>
    <!-- modulecode//function: local assignment handling -->
    <admst:template match="function:assignment">
      <admst:for-each select="@exfunction[name!='\$simparam' and #class='builtin']">
        <admst:choose>
          <admst:when test="[count(arguments)=1]">
            <admst:text format="_%(fgetname(.)/[name='fgetname']/value)(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1),"/>
            <admst:join select="arguments" separator=",">
              <admst:text format="(%(estringifynoprobe(.)/[name='ret']/value))"/>
            </admst:join>
            <admst:text format=")\n"/>
            <admst:text format="EXIT_IF_ISNAN(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1))\n"/>
          </admst:when>
          <admst:when test="[count(arguments)=2]">
            <admst:text format="_%(fgetname(.)/[name='fgetname']/value)"/>
            <admst:text test="[name='div']" format="0"/>
            <admst:text format="(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1),"/>
            <admst:join select="arguments" separator=",">
              <admst:text format="%(estringifynoprobe(.)/[name='ret']/value)"/>
            </admst:join>
            <admst:text format=")\n"/>
            <admst:text format="EXIT_IF_ISNAN(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1))\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:error format="%(name):function not handled\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:template>
    <!-- modulecode//function: ddx handling -->
    <admst:template match="ddx:function:computation">
      <admst:if test="[datatypename='contribution' or lhs/prototype/#insource=1]">
        <admst:if test="rhs[#hasVoltageDependentFunction='yes']">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="rhs/@exfunction">
            <admst:if test="[count(arguments)=1]">
              <admst:for-each select="arguments[1]">
                <admst:text test="[#dependency!='constant']" format="double __d_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1)=0.0;\n"/>
              </admst:for-each>
            </admst:if>
            <admst:if test="[count(arguments)=2]">
              <admst:for-each select="arguments">
                <admst:if test="[position()=1]">
                  <admst:text test="[(../name='div') or (#dependency!='constant')]" format="double __dFx_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1)=0.0;\n"/>
                </admst:if>
                <admst:if test="[position()=2]">
                  <admst:text test="[#dependency!='constant']" format="double __dFy_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1)=0.0;\n"/>
                </admst:if>
              </admst:for-each>
            </admst:if>
          </admst:for-each>
          <admst:text format="#endif /* _DERIVATE */\n"/>
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="rhs/@exfunction">
            <admst:if test="[count(arguments)=1]">
              <admst:for-each select="arguments[1]">
                <admst:apply-templates select="." match="estringifynoprobe"/>
                <admst:choose>
                  <admst:when test="[#dependency!='constant']">
                    <admst:text format="_d_%(fgetname(..)/[name='fgetname']/value)(__%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),__d_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),($ztmp))\n"/>
                    <admst:text format="EXIT_IF_ISNAN(__%(fgetname(..)/[name='fgetname']/value)_%(../position()-1))\n"/>
                    <admst:text format="EXIT_IF_ISNAN(__d_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1))\n"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:text format="_%(fgetname(..)/[name='fgetname']/value)(__%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),($ztmp))\n"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:for-each>
            </admst:if>
            <admst:if test="[count(arguments)=2]">
              <admst:text format="_%(fgetname(.)/[name='fgetname']/value)(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1),"/>
              <admst:text test="[name='div']" format="__dFx_%(name)_%(position()-1),"/>
              <admst:join select="arguments" separator=",">
                <admst:text format="%(estringifynoprobe(.)/[name='ret']/value)"/>
              </admst:join>
              <admst:text format=")\n"/>
              <admst:for-each select="arguments">
                <admst:if test="[position()=1]">
                  <admst:if test="[#dependency!='constant']">
                    <admst:text format="_dx_%(fgetname(..)/[name='fgetname']/value)(__dFx_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),__%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),"/>
                    <admst:join select="../arguments" separator=",">
                      <admst:text format="%(estringifynoprobe(.)/[name='ret']/value)"/>
                    </admst:join>
                    <admst:text format=")\n"/>
                    <admst:text format="EXIT_IF_ISNAN(__dFx_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1))\n"/>
                  </admst:if>
                </admst:if>
                <admst:if test="[position()=2]">
                  <admst:if test="[#dependency!='constant']">
                    <admst:text format="_dy_%(fgetname(..)/[name='fgetname']/value)(__dFy_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),"/>
                    <admst:text test="[../name='div']" format="__dFx_%(../name)_%(../position()-1),"/>
                    <admst:text format="__%(fgetname(..)/[name='fgetname']/value)_%(../position()-1),"/>
                    <admst:join select="../arguments" separator=",">
                      <admst:text format="%(estringifynoprobe(.)/[name='ret']/value)"/>
                    </admst:join>
                    <admst:text format=")\n"/>
                    <admst:text format="EXIT_IF_ISNAN(__dFy_%(fgetname(..)/[name='fgetname']/value)_%(../position()-1))\n"/>
                  </admst:if>
                </admst:if>
              </admst:for-each>
              <admst:text format="EXIT_IF_ISNAN(__%(fgetname(.)/[name='fgetname']/value)_%(position()-1))\n"/>
            </admst:if>
          </admst:for-each>
          <admst:text format="#else\n"/>
        </admst:if>
      </admst:if>
      <admst:apply-templates select="rhs" match="function:assignment"/>
      <admst:if test="[datatypename='contribution' or lhs/prototype/#insource=1]">
        <admst:text test="rhs[#hasVoltageDependentFunction='yes']" format="#endif\n"/>
      </admst:if>
    </admst:template>
    <!-- modulecode//assignment -->
    <admst:template match="assignment">
      <admst:if test="rhs[exists(@exfunction[#class='builtin'])]">
        <admst:choose>
          <admst:when test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
            <admst:text format="#if defined(_DYNAMIC)\n"/>
          </admst:when>
        </admst:choose>
        <admst:text format="{\n"/>
        <admst:text select="rhs/@exfunction" format="double __%(fgetname(.)/[name='fgetname']/value)_%(position()-1)=0.0;\n"/>
        <admst:apply-templates select="." match="ddx:function:computation"/>
      </admst:if>
      <admst:text test="lhs[prototype/#derivate='yes']" format="#if defined(_DERIVATE)\n"/>
      <admst:if test="lhs/prototype[#insource=1]">
        <admst:if test="rhs/@exprobe">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="rhs/@exprobe">
            <admst:variable name="zprobe" path="."/>
            <admst:apply-templates select=".." match="subexpression:differentiate"/>
            <admst:text format="%(../../lhs/name)_%(nature/access)%(pnode/name)_%(nnode/name)=$zddx;\n"/>
            <admst:text format="EXIT_IF_ISNAN(%(../../lhs/name)_%(nature/access)%(pnode/name)_%(nnode/name))\n"/>
          </admst:for-each>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:if>
      <admst:choose>
        <admst:when test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
          <admst:text format="#if defined(_DYNAMIC)\n"/>
        </admst:when>
      </admst:choose>
      <admst:apply-templates select="lhs" match="variable:lhs"/>
      <admst:text format="=%(estringifynoprobe(rhs)/[name='ret']/value);\n"/>
      <admst:text format="EXIT_IF_ISNAN("/>
      <admst:apply-templates select="lhs" match="variable:lhs"/>
      <admst:text format=")\n"/>
      <admst:choose>
        <admst:when test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
          <admst:text format="#endif /*_DYNAMIC*/\n"/>
        </admst:when>
      </admst:choose>
      <admst:text test="lhs[prototype/#derivate='yes']" format="#endif /*_DERIVATE*/\n"/>
      <admst:if test="lhs/prototype[#insource=1]">
        <admst:if test="lhs/prototype/@vpprobe">
          <admst:text format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="lhs/prototype/@vpprobe">
            <admst:variable name="p" path="."/>
            <admst:text test="[nilled(../../../rhs/@exprobe[$p/nature=nature and $p/pnode=pnode and $p/nnode=nnode])]" format="%(../name)_%(nature/access)%(pnode/name)_%(nnode/name)=0.0;\n"/>
          </admst:for-each>
          <admst:text format="#endif /*_DERIVATE*/\n"/>
        </admst:if>
      </admst:if>
      <admst:if test="rhs[exists(@exfunction[#class='builtin'])]">
        <admst:text format="}\n"/>
        <admst:choose>
          <admst:when test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
            <admst:text format="#endif /* _DYNAMIC */\n"/>
          </admst:when>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- modulecode//conditional -->
    <admst:template match="conditional">
      <admst:if test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
        <admst:choose>
          <admst:when test="[nilled(elsecode)]">
            <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthen&gt;*/\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="#ifdef _DYNAMIC /*&lt;dynamic_ifthenelse&gt;*/\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:if test="ifcondition[exists(@exfunction[#class='builtin'])]">
        <admst:text format="{\n"/>
        <admst:text select="ifcondition/@exfunction" format="double __%(fgetname(.)/[name='fgetname']/value)_%(position()-1)=0.0;\n"/>
        <admst:apply-templates select="ifcondition" match="function:assignment"/>
      </admst:if>
      <admst:text format="if\n(%(estringifynoprobe(ifcondition)/[name='ret']/value))\n"/>
      <admst:text test="thencode[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="thencode" match="%(datatypename)"/>
      <admst:text test="thencode[datatypename!='block']" format="}\n"/>
      <admst:if test="[exists(elsecode)]">
        <admst:text format="else\n"/>
        <admst:choose>
          <admst:when test="elsecode[datatypename='block']">
            <admst:apply-templates select="elsecode" match="%(datatypename)"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="{\n"/>
            <admst:apply-templates select="elsecode" match="%(datatypename)"/>
            <admst:text format="}\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
      <admst:text test="ifcondition[exists(@exfunction[#class='builtin'])]" format="}\n"/>
      <admst:if test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
        <admst:choose>
          <admst:when test="[nilled(elsecode)]">
            <admst:text format="#endif /*&lt;/dynamic_ifthen&gt;*/\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="#endif /*&lt;/dynamic_ifthenelse&gt;*/\n"/>
          </admst:otherwise>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- modulecode//case -->
    <admst:template match="case">
      <admst:error format="case statement: please implement me! (inside block)\n"/>
      <admst:text format="/*CASE*/;\n"/>
    </admst:template>
    <!-- modulecode//nilled -->
    <admst:template match="nilled">
      <admst:text format=";\n"/>
    </admst:template>
    <!-- modulecode//whileloop -->
    <admst:template match="whileloop">
      <admst:text test="whilecode[#modifyss!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#ifdef _DYNAMIC /*&lt;dynamic_while&gt;*/\n"/>
      <admst:if test="whilecondition[exists(@exfunction[#class='builtin'])]">
        <admst:text format="{\n"/>
        <admst:text select="whilecondition/@exfunction" format="double __%(fgetname(.)/[name='fgetname']/value)_%(position()-1)=0.0;\n"/>
        <admst:apply-templates select="whilecondition" match="function:assignment"/>
      </admst:if>
      <admst:text format="while\n(%(estringifynoprobe(whilecondition)/[name='ret']/value))\n"/>
      <admst:text test="whilecode[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="whilecode" match="%(datatypename)"/>
      <admst:text test="whilecode[datatypename!='block']" format="}\n"/>
      <admst:text test="whilecondition[exists(@exfunction[#class='builtin'])]" format="}\n"/>
      <admst:text test="whilecode[#modifyss!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
    </admst:template>
    <!-- modulecode//callfunctions -->
    <admst:template match="callfunction">
      <admst:choose>
        <admst:when test="[name='\$strobe']">
          <admst:text format="_strobe("/>
        </admst:when>
        <admst:when test="[name='\$warning']">
          <admst:text format="_warning("/>
        </admst:when>
        <admst:when test="[name='\$error']">
          <admst:text format="_error("/>
        </admst:when>
        <admst:when test="[name='\$finish']">
          <admst:text format="_finish("/>
        </admst:when>
        <admst:when test="[name='\$stop']">
          <admst:text format="_stop("/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="function not supported: %(name)($ztmp)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="ztmp"/>
      <admst:join select="arguments" separator=",">%(estringifynoprobe(.)/[name='ret']/value)</admst:join>
      <admst:text format=");\n"/>
    </admst:template>
    <!-- expression//probe -->
    <admst:template match="probe">
      <admst:choose>
        <admst:when test="nnode[location!='ground']">
          <admst:variable name="ztmp" string="BP(%(pnode/name),%(nnode/name))"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ztmp" string="voltages(%(pnode/name))"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <!-- expression//modulenode -->
    <admst:template match="node">
      <admst:error format="module node not expected here ... %(name)\n"/>
    </admst:template>
    <!-- expression//string -->
    <admst:template match="string">
      <admst:variable name="ztmp" string="&quot;%(value)&quot;"/>
    </admst:template>
    <!-- modulecode//@contribution[noise] -->
    <admst:template match="contribution:noise">
      <admst:if test="[#modifyfn=1]">
        <admst:text format="ngspice_flickernoise(%(pnode/name),%(nnode/name)"/>
        <admst:error test="rhs[datatypename!='function']" format="noise term inside expression not supported!\n"/>
        <admst:for-each select="rhs[datatypename='function' and arity='nary']/arguments">
          <admst:apply-templates select="." match="%(datatypename)"/>
          <admst:text format=",$ztmp"/>
        </admst:for-each>
        <admst:text test="[count(rhs[datatypename='function' and arity='nary']/arguments)=2]" format=",NULL"/>
      </admst:if>
      <admst:if test="[#modifywn=1]">
        <admst:text format="ngspice_whitenoise(%(pnode/name),%(nnode/name)"/>
        <admst:for-each select="rhs[datatypename='function' and arity='nary']/arguments">
          <admst:apply-templates select="." match="%(datatypename)"/>
          <admst:text format=",$ztmp"/>
        </admst:for-each>
        <admst:text test="[count(rhs[datatypename='function' and arity='nary']/arguments)=1]" format=",NULL"/>
      </admst:if>
      <admst:text format=")\n"/>
    </admst:template>
    <!-- variable:rhs -->
    <admst:template match="variablep">
      <admst:choose>
        <admst:when test="[isparameter='yes' and #parametertype!='instance']">
          <admst:variable name="ztmp" string="model-&gt;%(name)"/>
        </admst:when>
        <admst:when test="[isparameter='no' and #scope='global_model']">
          <admst:variable name="ztmp" string="model-&gt;%(name)"/>
        </admst:when>
        <admst:when test="[isparameter='yes' and #parametertype='instance']">
          <admst:variable name="ztmp" string="here-&gt;%(name)"/>
        </admst:when>
        <admst:when test="[isparameter='no' and #scope='global_instance']">
          <admst:variable name="ztmp" string="here-&gt;%(name)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ztmp" string="%(name)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="variable">
      <admst:apply-templates select="prototype" match="variablep"/>
    </admst:template>
    <!-- variable:lhs -->
    <admst:template match="variable:lhs">
      <admst:text test="prototype[isparameter='yes' and #parametertype!='instance']" format="model-&gt;%(name)"/>
      <admst:text test="prototype[isparameter='yes' and #parametertype='instance']" format="here-&gt;%(name)"/>
      <admst:text test="prototype[isparameter='no' and #scope='global_model']" format="model-&gt;%(name)"/>
      <admst:text test="prototype[isparameter='no' and #scope='global_instance']" format="here-&gt;%(name)"/>
      <admst:text test="prototype[(#scope!='global_model' and #scope!='global_instance')]" format="%(name)"/>
    </admst:template>
    <!-- handle modulecode//callfunctions -->
    <admst:template match="callfunction">
      <admst:choose>
        <admst:when test="[name='\$strobe']">
          <admst:text format="fprintf(stdout"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="%(name): not supported by this interface\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:text select="arguments" format=",%(estringifynoprobe(.)/[name='ret']/value)"/>
      <admst:text format=");\n"/>
      <admst:choose>
        <admst:when test="[name='\$strobe']">
          <admst:text format="fprintf(stdout,&quot;\\n&quot;);\n"/>
        </admst:when>
      </admst:choose>
    </admst:template>
    <admst:for-each select="/@module">
        <admst:variable name="fnoise"/>
        <admst:variable name="tnoise"/>
        <admst:variable name="wnoise"/>
      <admst:for-each select="@contribution">
        <admst:choose>
          <admst:when test="rhs[datatypename='function' and arity='nary' and name='flicker_noise']">
            <admst:push select="$fnoise" path="." oncompare="."/>
          </admst:when>
          <admst:when test="[#dependency='constant']/rhs[datatypename='function' and arity='nary' and name='white_noise']">
            <admst:push select="$tnoise" path="." oncompare="."/>
          </admst:when>
          <admst:when test="[#dependency!='constant']/rhs[datatypename='function' and arity='nary' and name='white_noise']">
            <admst:push select="$wnoise" path="." oncompare="."/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[name='hic0_full']">
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="hicum0"/>
          </admst:new>
        </admst:when>
        <admst:when test="[name='hic2_full']">
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="hicum2"/>
          </admst:new>
        </admst:when>
        <admst:when test="[name='bjt504tva']">
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="bjt504t"/>
          </admst:new>
        </admst:when>
        <admst:when test="[name='pjfet_va']">
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="pjfet_va"/>
          </admst:new>
        </admst:when>
        <admst:when test="[lower-case(name)='psp102va']">
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="psp102"/>
          </admst:new>
        </admst:when>
        <admst:otherwise>
          <admst:new datatype="attribute" inputs="'ngspicename'">
            <admst:push select="../attribute" path="."/>
            <admst:value-to select="value" string="%(../name)"/>
          </admst:new>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[name='r2_et_cmc' or name='r2_cmc']">
      </admst:when>
        <admst:when test="[name='mosvar']">
          <admst:if test="[nilled(modulevariablep[name='c'])]">
            <admst:new datatype="variablep" inputs="'c'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:when test="[name='juncap2']">
          <admst:if test="[nilled(modulevariablep[name='d'])]">
            <admst:new datatype="variablep" inputs="'d'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:when test="[name='vbic' or name='hic0_full' or name='hic2_full' or name='bjt504tva']">
          <admst:if test="[nilled(modulevariablep[name='npn'])]">
            <admst:new datatype="variablep" inputs="'npn'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
          <admst:if test="[nilled(modulevariablep[name='pnp'])]">
            <admst:new datatype="variablep" inputs="'pnp'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="0">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:when test="[lower-case(name)='igbt']">
          <admst:if test="[nilled(modulevariablep[name='xigbt'])]">
            <admst:new datatype="variablep" inputs="'xigbt'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:when test="[lower-case(name)='psp102va']">
          <admst:if test="[nilled(modulevariablep[name='nmos'])]">
            <admst:new datatype="variablep" inputs="'nmos'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
          <admst:if test="[nilled(modulevariablep[name='pmos'])]">
            <admst:new datatype="variablep" inputs="'pmos'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:when test="[name='ekv']">
          <admst:if test="[nilled(modulevariablep[name='nmos'])]">
            <admst:new datatype="variablep" inputs="'nmos'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
          <admst:if test="[nilled(modulevariablep[name='pmos'])]">
            <admst:new datatype="variablep" inputs="'pmos'">
              <admst:push select="../modulevariablep" path="." oncompare="."/>
              <admst:value-to select="sizetype" string="scalar"/>
              <admst:value-to select="type" string="integer"/>
              <admst:value-to select="isparameter" string="yes"/>
              <admst:value-to select="#output" string="yes"/>
              <admst:value-to select="#parametertype" string="model"/>
              <admst:value-to select="#scope" string="global_model"/>
              <admst:new datatype="number" inputs="1">
                <admst:value-to select="scalingunit" string="1"/>
                <admst:value-to select="../default" path="."/>
              </admst:new>
            </admst:new>
          </admst:if>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(name): device not handled by the ngspice interface\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEtemp.c.xml" ?>
    <admst:template match="dectype">
      <admst:choose>
        <admst:when test="[type='real']">
          <admst:text format="  double "/>
        </admst:when>
        <admst:when test="[type='integer']">
          <admst:text format="  int "/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="  char* "/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="code:ng1">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

//fixme!!! redundant
#define max(x,y)        (((x)&gt;(y))?(x):(y))
#define min(x,y)       (((x)&lt;(y))?(x):(y))
#define logE(x)         log(x)

#define _STATIC
#define _DYNAMIC

int $(module)temp(GENmodel *inModel, CKTcircuit *ckt)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  NG_IGNOREABLE(ckt);
  for ( ; model != NULL; model = model-&gt;$(module)nextModel )
  {

<admst:apply-templates select="modulecode" match="modulecode:initial_model"/>
    /* loop through all the instances of the model */
    for (here = model-&gt;$(module)instances; here != NULL ; here = here-&gt;$(module)nextInstance)
    {

<admst:apply-templates select="modulecode" match="modulecode:initial_instance"/>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>
<admst:template match="code:create_makefile_am">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>
## Process this file with automake to produce Makefile.in

ADMSXMLINTERFACE=\$(srcdir)/../admst

noinst_LTLIBRARIES = lib$(module).la

BUILT_SOURCES = \\
	$(module).c		\\
	$(module).hxx		\\
	$(module)acld.c	\\
	$(module)ask.c	\\
	$(module)itf.h	\\
	$(module)del.c	\\
	$(module)dest.c	\\
	$(module)init.c	\\
	$(module)load.c	\\
	$(module)mask.c	\\
	$(module)mdel.c	\\
	$(module)mpar.c	\\
	$(module)par.c	\\
	$(module)pzld.c	\\
	$(module)setup.c	\\
	$(module)temp.c	\\
	$(module)trunc.c

lib$(module)_la_SOURCES = \\
	\$(BUILT_SOURCES)

CLEANFILES = \\
	\$(BUILT_SOURCES) \\
	.$(module).va.adms \\
	.interface.xml \\
	*.h \\
	*.xml

AM_CPPFLAGS = @AM_CPPFLAGS@ -I\$(top_srcdir)/src/include

MAINTAINERCLEANFILES = Makefile.in

%.c %.hxx \\
	%acld.c %ask.c %itf.h %del.c %dest.c \\
	%init.c %load.c %mask.c %mdel.c %mpar.c %par.c \\
        %pzld.c %setup.c %temp.c %trunc.c \\
: \$(srcdir)/adms3va/%.va \$(ADMSXMLINTERFACE)/prengspice.xml \$(ADMSXMLINTERFACE)/ngspice.xml
	admsXml -I\$(srcdir) -I\$(srcdir)/adms3va -f \$&lt; -e \$(ADMSXMLINTERFACE)/prengspice.xml
	admsXml -I\$(srcdir) -f mna.va -e \$(ADMSXMLINTERFACE)/ngspice.xml

</admst:template>
    <admst:if test="[exists(/argv[.='--create_makefile_am'])]">
      <admst:message format="flag &quot;--create_makefile_am&quot; found at the command line\n"/>
      <admst:for-each select="/@module">
        <admst:open file="Makefile.am">
          <admst:text format="## created automatically\n"/>
          <admst:text format="## by: %(/fullname) - %(/currentdate)\n"/>
          <admst:apply-templates select="." match="code:create_makefile_am"/>
        </admst:open>
        <admst:message format="Makefile.am: file created\n"/>
      </admst:for-each>
      <admst:break/>
    </admst:if>
<admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)temp.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng1"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)temp.c: file created\n"/>
</admst:for-each>

<?escript name="ngspice_1_0_1/ngspiceMODULEinit.c.xml" ?>
<admst:template match="code:ng3">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

SPICEadmsdev $(module)admsinfo = {
  {
    {   "$module",
        "$module created by adms",
        &amp;$(module)nSize,
        &amp;$(module)nSize,
        $(module)names,
        &amp;$(module)pTSize,
        $(module)pTable,
        &amp;$(module)mPTSize,
        $(module)mPTable,
  #ifdef XSPICE
  /*----  Fixed by SDB 5.2.2003 to enable XSPICE/tclspice integration  -----*/
          NULL,  /* This is a SPICE device, it has no MIF info data */
  
          0,     /* This is a SPICE device, it has no MIF info data */
          NULL,  /* This is a SPICE device, it has no MIF info data */
  
          0,     /* This is a SPICE device, it has no MIF info data */
          NULL,  /* This is a SPICE device, it has no MIF info data */
  
          0,     /* This is a SPICE device, it has no MIF info data */
          NULL,  /* This is a SPICE device, it has no MIF info data */
  /*---------------------------  End of SDB fix   -------------------------*/
  #endif
        DEV_DEFAULT
    },
    $(module)par,    /* DEVparam       */
    $(module)mParam,   /* DEVmodParam    */
    $(module)load,     /* DEVload        */
    $(module)setup,    /* DEVsetup       */
    NULL,  /* DEVunsetup     */
    $(module)setup,    /* DEVpzSetup     */
    $(module)temp,     /* DEVtemperature */
    $(module)trunc,    /* DEVtrunc       */
    NULL,         /* DEVfindBranch  */
    $(module)acLoad,   /* DEVacLoad      */
    NULL,         /* DEVaccept      */
    $(module)destroy,  /* DEVdestroy     */
    $(module)mDelete,  /* DEVmodDelete   */
    $(module)delete,   /* DEVdelete      */
    NULL,    /* DEVsetic       */
    $(module)ask,      /* DEVask         */
    $(module)mAsk,     /* DEVmodAsk      */
    $(module)pzLoad,   /* DEVpzLoad      */
    NULL, /* DEVconvTest    */
    NULL,         /* DEVsenSetup    */
    NULL,         /* DEVsenLoad     */
    NULL,         /* DEVsenUpdate   */
    NULL,         /* DEVsenAcLoad   */
    NULL,         /* DEVsenPrint    */
    NULL,         /* DEVsenTrunc    */
    NULL,         /* DEVdisto       */
    NULL,         /* DEVnoise       */
#ifdef CIDER
    NULL,         /* DEVdump       */
    NULL,         /* DEVacct       */
#endif                                                         
    &amp;$(module)iSize,   /* DEVinstSize    */
    &amp;$(module)mSize    /* DEVmodSize     */

  }, /*SPICEdev*/
  NULL, /*mkn*/
  NULL  /*mkj*/
};

SPICEadmsdev *
get_$(module)_info(void)
{
    return &amp;$(module)admsinfo;
}

</admst:template>
<admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)init.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng3"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)init.c: file created\n"/>
</admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEitf.h.xml" ?>
<admst:template match="code:ng6">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#ifndef $(module)
#define $(module)

#include &quot;ngspice/ngspice.h&quot;
#include &quot;ngspice/devdefs.h&quot;
#include &quot;ngspice/sperror.h&quot;

#ifndef DEV_$(module)
#define DEV_$(module)

extern SPICEadmsdev *get_$(module)_info(void);

#endif

#ifndef __$(module)EXT_H
#define __$(module)EXT_H

<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

extern int $(module)par(int,IFvalue*,GENinstance*,IFvalue*);
extern int $(module)mParam(int,IFvalue*,GENmodel*);
extern int $(module)load(GENmodel*,CKTcircuit*);
extern int $(module)setup(SMPmatrix*,GENmodel*,CKTcircuit*,int*);
extern int $(module)temp(GENmodel*,CKTcircuit*);
extern int $(module)ask(CKTcircuit *,GENinstance*,int,IFvalue*,IFvalue*);
extern int $(module)mAsk(CKTcircuit*,GENmodel *,int, IFvalue*);
extern int $(module)acLoad(GENmodel *,CKTcircuit*);
extern int $(module)convTest(GENmodel *,CKTcircuit*);
extern int $(module)delete(GENmodel*,IFuid,GENinstance**);
extern int $(module)getic(GENmodel*,CKTcircuit*);
extern int $(module)mDelete(GENmodel**,IFuid,GENmodel*);
extern int $(module)noise(int,int,GENmodel*,CKTcircuit*,Ndata*,double*);
extern int $(module)pzLoad(GENmodel*,CKTcircuit*,SPcomplex*);
extern int $(module)trunc(GENmodel*,CKTcircuit*,double*);
extern int $(module)unsetup(GENmodel*,CKTcircuit*);
extern void $(module)destroy(GENmodel**);

#endif

#ifndef _$(module)INIT_H
#define _$(module)INIT_H

extern IFparm $(module)pTable[ ];
extern IFparm $(module)mPTable[ ];
extern char *$(module)names[ ];
extern int $(module)pTSize;
extern int $(module)mPTSize;
extern int $(module)nSize;
extern int $(module)iSize;
extern int $(module)mSize;

#endif

<admst:for-each select="modulevariablep">
<admst:variable name="variable" string="%(name)"/>
#ifdef $(variable)
  #warning conflict: $(variable) is declared as a variable of module '$(module)'.
  #warning conflict: However in the API of ngspice '$(variable)' is also defined as a pragma.
  #warning conflict: Pragma '$(variable)' will be undefined.
  #warning conflict: You can solve the confict by renaming variable '$(variable)' in module '$(module)'.
  #undef $(variable)
#endif
</admst:for-each>
<admst:for-each select="modulenode">
<admst:variable name="node" string="%(name)"/>
#ifdef $(variable)
  #warning conflict: $(node) is declared as a node of module '$(module)'.
  #warning conflict: However in the API of ngspice '$(node)' is also defined as a pragma.
  #warning conflict: Pragma '$(node)' will be undefined.
  #warning conflict: You can solve the confict by renaming variable '$(node)' in module '$(module)'.
  #undef $(variable)
#endif
</admst:for-each>

#ifdef NGSPICE_DEBUG_OK
#define NGSPICE_DEBUG \\
{ \\
  if(getenv("ngspice_debug")) \\
    $(module)debug(ckt,model,here); \\
  else \\
  { \\
    printf("  To get more info run your simulation after setting shell variable ngspice_debug to 1\\n"); \\
    printf("  For example in sh shell just type: export ngspice_debug=1\\n"); \\
  } \\
}
#else
#define NGSPICE_DEBUG
#endif

#define myFREE(x)        {if(x) { free(x); (x) = 0; }}

#define EXIT_IF_ISNAN(var) \\
if(isnan((double) var)) \\
{ \\
  printf("%s:%i:bug:isnan:"#var"\\n",__FILE__,__LINE__); \\
  printf("Please send this message to laurent.lemaitre@freescale.com\\n"); \\
  NGSPICE_DEBUG \\
  exit(1); /*__asm__ __volatile__ ("int \$03");*/ \\
} \\
if(isinf((double) var)) \\
{ \\
  printf("%s:%i:bug:isinf:"#var"\\n",__FILE__,__LINE__); \\
  printf("Please send this message to laurent.lemaitre@freescale.com\\n"); \\
  NGSPICE_DEBUG \\
  exit(1); /*__asm__ __volatile__ ("int \$03");*/ \\
}

/* ngspice \$simparam variables
    gdev                (1/Ohms): Additional conductance to be added to nonlinear branches for conductance homotopy convergence algorithm.
    gmin                (1/Ohms): Minimum conductance placed in parallel with nonlinear branches.
    imax                (Amps)  : Branch current threshold above which the constitutive relation of a nonlinear branch should be linearized.
    imelt               (Amps)  : Branch current threshold indicating device failure.
    iteration                   : Iteration number of the analog solver.
    scale                       : Scale factor for device instance geometry parameters.
    shrink                      : Optical linear shrink factor.
    simulatorSubversion         : The simulator sub-version.
    simulatorVersion            : The simulator version.
    sourceScaleFactor           : Multiplicative factor for independent sources for source stepping homotopy convergence algorithm.
    tnom degrees       (Celsius): Default value of temperature at which model parameters were extracted.
*/

#define _circuit_gdev                ckt-&gt;CKTgmin
#define _circuit_gmin                ((ckt-&gt;CKTgmin)&gt;(ckt-&gt;CKTdiagGmin))?(ckt-&gt;CKTgmin):(ckt-&gt;CKTdiagGmin)
#define _circuit_imax                1.0
#define _circuit_imelt               1.0
#define _circuit_iteration           1.0
#define _circuit_scale               1.0
#define _circuit_shrink              1.0
#define _circuit_simulatorSubversion 0
#define _circuit_simulatorVersion    3.5
#define _circuit_sourceScaleFactor   1.0
#define _circuit_tnom                ckt-&gt;CKTnomTemp

#define _circuit_temp      ckt-&gt;CKTtemp
#define _scale             1.0

#define _cos(val,arg)            val = cos(arg);
#define _d_cos(val,dval,arg)     val = cos(arg);     dval = (-sin(arg));
#define _sin(val,arg)            val = sin(arg);
#define _d_sin(val,dval,arg)     val = sin(arg);     dval = (cos(arg));
#define _tan(val,arg)            val = tan(arg);
#define _d_tan(val,dval,arg)     val = tan(arg);     dval = (1.0/cos(arg)/cos(arg));
#define _hypot(xy,x,y)           xy = sqrt((x)*(x)+(y)*(y));
#define _dx_hypot(dx,xy,x,y)     dx = (x)/(xy);
#define _dy_hypot(dy,xy,x,y)     dy = (y)/(xy);
#define _max(xy,x,y)             xy = ((x)&gt;(y))?(x):(y);
#define _dx_max(dx,xy,x,y)       dx = ((x)&gt;(y))?1.0:0.0;
#define _dy_max(dy,xy,x,y)       dy = ((x)&gt;(y))?0.0:1.0;
#define _min(xy,x,y)             xy = ((x)&lt;(y))?(x):(y);
#define _dx_min(dx,xy,x,y)       dx = ((x)&lt;(y))?1.0:0.0;
#define _dy_min(dy,xy,x,y)       dy = ((x)&lt;(y))?0.0:1.0;
#define _cosh(val,arg)           val = cosh(arg);
#define _d_cosh(val,dval,arg)    val = cosh(arg);    dval = (sinh(arg));
#define _sinh(val,arg)           val = sinh(arg);
#define _d_sinh(val,dval,arg)    val = sinh(arg);    dval = (cosh(arg));
#define _tanh(val,arg)           val = tanh(arg);
#define _d_tanh(val,dval,arg)    val = tanh(arg);    dval = (1.0/cosh(arg)/cosh(arg));
#define _acos(val,arg)           val = acos(arg);
#define _d_acos(val,dval,arg)    val = acos(arg);    dval = (-1.0/sqrt(1-arg*arg));
#define _asin(val,arg)           val = asin(arg);
#define _d_asin(val,dval,arg)    val = asin(arg);    dval = (+1.0/sqrt(1-arg*arg));
#define _atan(val,arg)           val = atan(arg);
#define _d_atan(val,dval,arg)    val = atan(arg);    dval = (+1.0/(1+arg*arg));
#define _logE(val,arg)           val = log(arg);
#define _d_logE(val,dval,arg)    val = log(arg);     dval = (1.0/arg);
#define _log10(val,arg)          val = log10(arg);
#define _d_log10(val,dval,arg)   val = log10(arg);   dval = (1.0/arg/log(10));
#define _exp(val,arg)            val = exp(arg);
#define _d_exp(val,dval,arg)     val = exp(arg);     dval = val;
#define _sqrt(val,arg)           val = sqrt(arg);
#define _d_sqrt(val,dval,arg)    val = sqrt(arg);    dval = (1.0/val/2.0);
#define _pow(xy,x,y)             xy = pow(x,y);
#define _dx_pow(dx,xy,x,y)       dx = (x==0.0)?0.0:((y/x)*xy);
#define _dy_pow(dy,xy,x,y)       dy = (x==0.0)?0.0:((log(x)/exp(0.0))*xy);

#define _div1(x,y)               ((x)/(y))
#define _div0(xy,x,y)            xy=(x)/(y);
#define _div(xy,dx,x,y)          dx=1/(y); xy=(x)*dx;
#define _dx_div(dx,xy,x,y)
#define _dy_div(dy,dx,xy,x,y)    dy = -xy*dx;

#define _limexp(val,arg)         val = ((arg)&lt;(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90)));
#define _d_limexp(val,dval,arg)  val = ((arg)&lt;(90)) ? (exp(arg)) : (exp(90)*(1.0+(arg-90))); dval = val;
#define _fabs(val,arg)           val = fabs(arg);
#define _d_fabs(val,dval,arg)    val = fabs(arg);    dval = (((val)&gt;=0)?(+1.0):(-1.0));
#define _abs(val)                ((val)&lt;(0) ? (-(val)):(val))

/* declarations for $(module) MOSFETs */

/* information needed for each instance */
typedef struct s$(module)instance {
  struct s$(module)model *$(module)modPtr;           /* pointer to model */
  struct s$(module)instance *$(module)nextInstance;  /* pointer to next instance of current model*/
  IFuid $(module)name; /* pointer to character string naming this instance */
  int $(module)owner;  /* number of owner process */
  int $(module)state; /* index into state table for this device */

  /* node */
<admst:for-each select="modulenode[location!='ground']">
<admst:text format="  int %(name)Node;"/>
<admst:text test="attribute[name='info']" format="  /*%(name)*/"/>
<admst:text format="\n"/>
</admst:for-each>
  /* instance parameters */
<admst:for-each select="modulevariablep[#parametertype='instance' and isparameter='yes']">
<admst:apply-templates select="." match="dectype"/>
<admst:text format="%(name);\n"/>
<admst:text format="  unsigned %(name)_Given  :1;"/>
<admst:text test="attribute[name='info']" format="  /*%(name)*/"/>
<admst:text format="\n"/>
</admst:for-each>
 // noise\n
  <admst:text select="$fnoise" format="  double fpnoise%(index($fnoise,.)), fenoise%(index($fnoise,.));\n"/>
  <admst:text select="$tnoise" format="  double tnoise%(index($tnoise,.));\n"/>
  <admst:text select="$wnoise" format="  double wnoise%(index($wnoise,.));\n"/>

  /* variables */
<admst:for-each select="modulevariablep[isparameter='no' and #scope='global_instance']">
<admst:apply-templates select="." match="dectype"/>
<admst:text format="%(name);\n"/>
<admst:text select="attribute[name='info']" format="  /*%(.)*/"/>
</admst:for-each>
  /* states */
<admst:text select="@npncontributionklass[exists(@kcontribution[#modifyd=1])]" format="  int state_%(pnode/name)_%(nnode/name);\n"/>
  /* pointer to sparse matrix (+ values)*/
<admst:for-each select="reverse(@jacobianklass)">
<admst:text format="  double *PTR_J_%(#row/name)_%(#column/name);\n"/>
<admst:text format="    int PTR_J_%(#row/name)_%(#column/name)_required;\n"/>
<admst:text test="[exists(@jcontribution[#modifyd!=1])]" format="    double JSVAL_%(#row/name)_%(#column/name);\n"/>
<admst:text test="[exists(@jcontribution[#modifyd=1])]" format="    double JDVAL_%(#row/name)_%(#column/name);\n"/>
</admst:for-each>

#define $(module)numStates 0

} $(module)instance ;


/* per model data */

typedef struct s$(module)model {         /* model structure */
  int $(module)modType;        /* type index of this device type */
  struct s$(module)model *$(module)nextModel; /* pointer to next possible model in linked list */
  $(module)instance * $(module)instances;  /* pointer to list of instances that have this model */
  IFuid $(module)modName;         /* pointer to the name of this model */

  /* model parameters */
  <admst:for-each select="modulevariablep[#parametertype!='instance' and isparameter='yes']">
<admst:apply-templates select="." match="dectype"/>
<admst:text format="%(name);\n"/>
<admst:text format="  unsigned %(name)_Given  :1;"/>
<admst:text test="attribute[name='info']" format="  /*%(name)*/"/>
<admst:text format="\n"/>
</admst:for-each>
  /* variable */
  <admst:for-each select="modulevariablep[isparameter='no' and #scope='global_model']">
<admst:apply-templates select="." match="dectype"/>
<admst:text format="%(name);\n"/>
<admst:text select="attribute[name='info']" format="  /*%(.)*/"/>
</admst:for-each>

} $(module)model;

  <admst:text format="  /* flags */\n"/>
  <admst:text format="typedef enum {\n"/>
  <admst:text select="modulevariablep[#parametertype!='instance' and isparameter='yes']" format="  $(module)_model_%(name),\n"/>
    <admst:text format="  $(module)_DUMMY_MODEL"/>
  <admst:text format="\n} e_$(module)_model;\n"/>
  <admst:text format="typedef enum {\n"/>
  <admst:text select="modulevariablep[#parametertype='instance' and isparameter='yes']" format="  $(module)_instance_%(name),\n"/>
  <admst:text format="  $(module)_DUMMY_INSTANCE"/>
  <admst:text format="\n} e_$(module)_instance;\n"/>
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#endif /*$(module)*/

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)itf.h">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng6"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)itf.h: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEask.c.xml" ?>
<admst:template match="code:ng7">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)ask(CKTcircuit *ckt, GENinstance *inst, int which, IFvalue *value, IFvalue *select)
{
  $(module)instance *instance = ($(module)instance*)inst;
  NG_IGNOREABLE(ckt);
  NG_IGNOREABLE(value);
  NG_IGNOREABLE(select);
  NG_IGNOREABLE(instance);
  switch (which) {
<admst:for-each select="modulevariablep[#parametertype='instance' and isparameter='yes']">
<admst:text format="  case  $(module)_instance_%(name)  :\n"/>
<admst:choose>
<admst:when test="[type='real']">
<admst:text format="    value-&gt;rValue = instance-&gt;%(name);\n"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format="    value-&gt;iValue = instance-&gt;%(name);\n"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
<admst:text format="    return OK;\n"/>
</admst:for-each>
  default:
    return(-1);
  }
  return(-1);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)ask.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng7"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)ask.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEmask.c.xml" ?>
    <admst:template match="code:ng8">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)mAsk(CKTcircuit *ckt, GENmodel *inst, int which, IFvalue *value)
{
  $(module)model *model = ($(module)model *)inst;
  NG_IGNOREABLE(ckt);
  switch (which) {
  <admst:for-each select="modulevariablep[#parametertype!='instance' and isparameter='yes']">
<admst:text format="  case  $(module)_model_%(name)  :\n"/>
<admst:choose>
<admst:when test="[type='real']">
<admst:text format="    value-&gt;rValue = model-&gt;%(name);\n"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format="    value-&gt;iValue = model-&gt;%(name);\n"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
<admst:text format="    return OK;\n"/>
</admst:for-each>
  default:
    return(-1);
  }
  return(-1);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)mask.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng8"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)mask.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEpar.c.xml" ?>
    <admst:template match="code:ng9">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)par(int param, IFvalue *value, GENinstance *inst, IFvalue *select)
{
  $(module)instance *myinstance = ($(module)instance*)inst;
  NG_IGNOREABLE(value);
  NG_IGNOREABLE(select);
  NG_IGNOREABLE(myinstance);
  switch (param) {
  <admst:for-each select="modulevariablep[#parametertype='instance' and isparameter='yes']">
<admst:text format="  case  $(module)_instance_%(name)  :\n"/>
<admst:choose>
<admst:when test="[type='real']">
<admst:text format="    myinstance-&gt;%(name) = value-&gt;rValue;\n"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format="    myinstance-&gt;%(name) = value-&gt;iValue;\n"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
<admst:text format="    myinstance-&gt;%(name)_Given = TRUE;\n"/>
<admst:text format="    break;\n"/>
</admst:for-each>
  default:
    return(-1);
  }
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)par.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng9"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)par.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEmpar.c.xml" ?>
    <admst:template match="code:ng10">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)mParam(int param, IFvalue *value, GENmodel *inMod)
{
  $(module)model *mod = ($(module)model*)inMod;
  switch (param) {

  <admst:for-each select="modulevariablep[#parametertype!='instance' and isparameter='yes']">
<admst:text format="  case  $(module)_model_%(name)  :\n"/>
<admst:choose>
<admst:when test="[type='real']">
<admst:text format="    mod-&gt;%(name) = value-&gt;rValue;\n"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format="    mod-&gt;%(name) = value-&gt;iValue;\n"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
<admst:text format="    mod-&gt;%(name)_Given = TRUE;\n"/>
<admst:text format="    break;\n"/>
</admst:for-each>
  default:
    return(-1);
  }
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)mpar.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng10"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)mpar.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEload.c.xml" ?>
    <admst:template match="code:ng11">
#define NGSPICE_DEBUG_OK

<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

#define ccap qcap+1
static int my$(module)NIintegrate(CKTcircuit *ckt, double *geq, double *ceq, double cap, int qcap)
{
    static char *ordmsg = "Illegal integration order";
    static char *methodmsg = "Unknown integration method";
    char *errMsg; //fixme cest une globale dans ngspice!!!!
    #define myTMALLOC(t,n)      (t*) malloc(sizeof(t) * (size_t)(n)) 

    switch(ckt->CKTintegrateMethod) {

    case TRAPEZOIDAL:
        switch(ckt->CKTorder) {
        case 1:
            *(ckt->CKTstate0+ccap) = ckt->CKTag[0] * (*(ckt->CKTstate0+qcap)) 
                    + ckt->CKTag[1] * (*(ckt->CKTstate1+qcap));
            break;
        case 2:
            *(ckt->CKTstate0+ccap) = - *(ckt->CKTstate1+ccap) * ckt->CKTag[1] + 
                    ckt->CKTag[0] * 
                    ( *(ckt->CKTstate0+qcap) - *(ckt->CKTstate1+qcap) );
            break;
        default:
            errMsg = myTMALLOC(char, strlen(ordmsg) + 1);
            strcpy(errMsg,ordmsg);
            return(E_ORDER);
        }
        break;
    case GEAR:
        *(ckt->CKTstate0+ccap)=0;
        switch(ckt->CKTorder) {

        case 6:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[6]* *(ckt->CKTstate6+qcap);
            /* fall through */
        case 5:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[5]* *(ckt->CKTstate5+qcap);
            /* fall through */
        case 4:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[4]* *(ckt->CKTstate4+qcap);
            /* fall through */
        case 3:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[3]* *(ckt->CKTstate3+qcap);
            /* fall through */
        case 2:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[2]* *(ckt->CKTstate2+qcap);
            /* fall through */
        case 1:
            *(ckt->CKTstate0+ccap) += ckt->CKTag[1]* *(ckt->CKTstate1+qcap);
            *(ckt->CKTstate0+ccap) += ckt->CKTag[0]* *(ckt->CKTstate0+qcap);
            break;

        default:
            return(E_ORDER);

        }
        break;

    default:
        errMsg = myTMALLOC(char, strlen(methodmsg) + 1);
        strcpy(errMsg,methodmsg);
        return(E_METHOD);
    }
    *ceq = *(ckt->CKTstate0+ccap) - ckt->CKTag[0] * *(ckt->CKTstate0+qcap);
    *geq = ckt->CKTag[0] * cap;
    return(OK);
}

/*fixme: noise not implemented in ngspice*/
#define ngspice_flickernoise(p,n,mag,freq,info)\\
{\\
}
#define ngspice_whitenoise(p,n,mag,info)\\
{\\
}

#define voltages(p) *(ckt-&gt;CKTrhsOld+here-&gt;p ## Node)
#define BP(p,n) (voltages(p)-voltages(n))
#define DBGNODE(p) printf(#p "=%i - v=%e\\n",here-&gt;p ## Node,voltages(p));

<admst:apply-templates select="." match="debug:strobe"/>

#define _STATIC
#define _DYNAMIC
#define _DERIVATE

#define _load_static_residual2(p,n,v)\\
  *(ckt-&gt;CKTrhs+here-&gt;p ## Node)-=v;\\
  *(ckt-&gt;CKTrhs+here-&gt;n ## Node)+=v;
#define _load_static_residual1(p,v)\\
  *(ckt-&gt;CKTrhs+here-&gt;p ## Node)-=v;

#define _load_static_jacobian4(Sp,Sn,Pp,Pn,v)\\
  _load_static_residual2(Sp,Sn,-v*BP(Pp,Pn))\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pn)+=v;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pn)-=v;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pp)-=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JSVAL_ ## Sn ## _ ## Pn)+=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pn)-=v;\\
  (here-&gt;JSVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_static_jacobian2s(Sp,Sn,Pp,v)\\
  _load_static_residual2(Sp,Sn,-v*voltages(Pp))\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pp)-=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JSVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_static_jacobian2p(Sp,Pp,Pn,v)\\
  _load_static_residual1(Sp,-v*BP(Pp,Pn))\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pn)-=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pn)-=v;
#define _load_static_jacobian1(Sp,Pp,v)\\
  _load_static_residual1(Sp,-v*voltages(Pp))\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JSVAL_ ## Sp ## _ ## Pp)+=v;

#define _load_dynamic_residual2(p,n,v)\\
if(ChargeComputationNeeded)\\
{\\
  int error;\\
  double unused;\\
  *(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n)=v;\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_##n)=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n);\\
  error = my$(module)NIintegrate(ckt,&amp;unused,&amp;unused,0.0,here-&gt;state_##p##_##n);\\
  if(error) return(error);\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_##n+1) = *(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
  *(ckt-&gt;CKTrhs+here-&gt;p##Node)-=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
  *(ckt-&gt;CKTrhs+here-&gt;n##Node)+=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_##n+1);\\
}
#define _load_dynamic_residual1(p,v)\\
if(ChargeComputationNeeded)\\
{\\
  int error;\\
  double unused;\\
  *(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND)=v;\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_GND)=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND);\\
  error = my$(module)NIintegrate(ckt,&amp;unused,&amp;unused,0.0,here-&gt;state_##p##_GND);\\
  if(error) return(error);\\
  if(ckt-&gt;CKTmode &amp; MODEINITTRAN)\\
    *(ckt-&gt;CKTstate1+here-&gt;state_##p##_GND+1) = *(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND+1);\\
  *(ckt-&gt;CKTrhs+here-&gt;p##Node)-=*(ckt-&gt;CKTstate0+here-&gt;state_##p##_GND+1);\\
}

#define _load_dynamic_jacobian4(Sp,Sn,Pp,Pn,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt-&gt;CKTag[0];\\
  double ceq=geq*BP(Pp,Pn);\\
  *(ckt-&gt;CKTrhs+here-&gt;Sp##Node)+=ceq;\\
  *(ckt-&gt;CKTrhs+here-&gt;Sn##Node)-=ceq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pn)+=geq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pn)-=geq;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pp)-=geq;\\
}\\
  (here-&gt;JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JDVAL_ ## Sn ## _ ## Pn)+=v;\\
  (here-&gt;JDVAL_ ## Sp ## _ ## Pn)-=v;\\
  (here-&gt;JDVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_dynamic_jacobian2s(Sp,Sn,Pp,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt-&gt;CKTag[0];\\
  double ceq=geq*voltages(Pp);\\
  *(ckt-&gt;CKTrhs+here-&gt;Sp##Node)+=ceq;\\
  *(ckt-&gt;CKTrhs+here-&gt;Sn##Node)-=ceq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here-&gt;PTR_J_ ## Sn ## _ ## Pp)-=geq;\\
}\\
  (here-&gt;JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JDVAL_ ## Sn ## _ ## Pp)-=v;
#define _load_dynamic_jacobian2p(Sp,Pp,Pn,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt-&gt;CKTag[0];\\
  double ceq=geq*BP(Pp,Pn);\\
  *(ckt-&gt;CKTrhs+here-&gt;Sp##Node)+=ceq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pn)-=geq;\\
}\\
  (here-&gt;JDVAL_ ## Sp ## _ ## Pp)+=v;\\
  (here-&gt;JDVAL_ ## Sp ## _ ## Pn)-=v;
#define _load_dynamic_jacobian1(Sp,Pp,v)\\
if(ChargeComputationNeeded)\\
{\\
  double geq=(v)*ckt-&gt;CKTag[0];\\
  double ceq=geq*voltages(Pp);\\
  *(ckt-&gt;CKTrhs+here-&gt;Sp##Node)+=ceq;\\
  *(here-&gt;PTR_J_ ## Sp ## _ ## Pp)+=geq;\\
}\\
(here-&gt;JDVAL_ ## Sp ## _ ## Pp)+=v;

int $(module)load(GENmodel *inModel, CKTcircuit *ckt)
     /* actually load the current value into the 
      * sparse matrix previously provided 
      */
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  int ChargeComputationNeeded =  
                 ((ckt-&gt;CKTmode &amp; (MODEAC | MODETRAN | MODEINITSMSIG)) ||
                 ((ckt-&gt;CKTmode &amp; MODETRANOP) &amp;&amp; (ckt-&gt;CKTmode &amp; MODEUIC)))
                 ? 1 : 0;

  for ( ; model != NULL; model = model-&gt;$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model-&gt;$(module)instances; here != NULL ; here = here-&gt;$(module)nextInstance)
    {
{
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd!=1])])" format="  here-&gt;JSVAL_%(#row/name)_%(#column/name)=0.0;\n"/>
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd=1])])" format="  here-&gt;JDVAL_%(#row/name)_%(#column/name)=0.0;\n"/>
}
{
#include &quot;$module.hxx&quot;
}
    } /* End of Instance */
  } /* End of Model */
  return(OK);
}

</admst:template>
    <!-- modulecode/![initializeModel|initializeInstance|initial_model|initial_instance|initial_step|noise] -->
    <admst:template match="debug:strobe">
      <admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>
      <admst:text format="static void $(module)debug (CKTcircuit *ckt, $(module)model *model, $(module)instance *here)\n"/>
      <admst:text format="{\n"/>
      <admst:text select="modulenode[location!='ground']" format="  fprintf(stdout,&quot;voltage: %(name)=%e\\n&quot;,voltages(%(name)));\n"/>
      <admst:for-each select="modulevariablep[isparameter='yes']">
        <admst:choose>
          <admst:when test="[type='integer']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;Parameter: %(#parametertype): %(name)=%i\\n&quot;,$ztmp);\n"/>
          </admst:when>
          <admst:when test="[type='real']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;Parameter: %(#parametertype): %(name)=%e\\n&quot;,$ztmp);\n"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:for-each select="modulevariablep[isparameter='no' and #scope='global_model' and #setinmodel='yes' and #insource=1]">
        <admst:choose>
          <admst:when test="[type='integer']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;model: %(name)=%i\\n&quot;,$ztmp);\n"/>
          </admst:when>
          <admst:when test="[type='real']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;model: %(name)=%e\\n&quot;,$ztmp);\n"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:for-each select="modulevariablep[isparameter='no' and #scope='global_instance' and #setininstance='yes' and #insource=1]">
        <admst:choose>
          <admst:when test="[type='integer']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;instance: %(name)=%i\\n&quot;,$ztmp);\n"/>
          </admst:when>
          <admst:when test="[type='real']">
            <admst:apply-templates select="." match="variablep"/>
            <admst:text format="  fprintf(stdout,&quot;instance: %(name)=%e\\n&quot;,$ztmp);\n"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:text format="}\n"/>
    </admst:template>
    <admst:template match="modulecode:evaluate">
        <admst:assert test="[datatypename='block']" format="expecting datatypename=block\n"/>
        <admst:for-each select="blockcode">
          <admst:if test="[datatypename='block']">
            <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='initializeModel' and name!='initializeInstance'            and name!='initial_step']">
              <admst:apply-templates select="." match="block:local:declaration"/>
            </admst:if>
          </admst:if>
          <admst:if test="[datatypename!='block']">
            <admst:apply-templates select="." match="block:local:declaration"/>
          </admst:if>
        </admst:for-each>
        <admst:apply-templates select="casecode" match="variable:declaration2"/>
        <admst:for-each select="blockcode">
          <admst:choose>
            <admst:when test="[datatypename!='block']">
              <admst:apply-templates select="." match="%(datatypename)"/>
            </admst:when>
            <admst:otherwise>
              <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='initializeModel' and name!='initializeInstance'              and name!='initial_step']">
                <admst:apply-templates select="." match="block"/>
              </admst:if>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
    </admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)load.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng11"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)load.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEacld.c.xml" ?>
    <admst:template match="code:ng12">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)acLoad(GENmodel *inModel, CKTcircuit *ckt)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  for ( ; model != NULL; model = model-&gt;$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model-&gt;$(module)instances; here != NULL ; here = here-&gt;$(module)nextInstance)
    {
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd!=1])])" format="  if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required) *(here-&gt;PTR_J_%(#row/name)_%(#column/name))+=here-&gt;JSVAL_%(#row/name)_%(#column/name);\n"/>
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd=1])])" format="  if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required) *(here-&gt;PTR_J_%(#row/name)_%(#column/name)+1)+=ckt-&gt;CKTomega*here-&gt;JDVAL_%(#row/name)_%(#column/name);\n"/>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)acld.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng12"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)acld.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEpzld.c.xml" ?>
    <admst:template match="code:ng13">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)pzLoad(GENmodel *inModel, CKTcircuit *ckt, SPcomplex *s)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
  NG_IGNOREABLE(ckt);
  for ( ; model != NULL; model = model-&gt;$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model-&gt;$(module)instances; here != NULL ; here = here-&gt;$(module)nextInstance)
    {
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd!=1])])" format="  if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required) *(here-&gt;PTR_J_%(#row/name)_%(#column/name))+=here-&gt;JSVAL_%(#row/name)_%(#column/name) *(s-&gt;real);\n"/>
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd=1])])" format="  if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required) *(here-&gt;PTR_J_%(#row/name)_%(#column/name))+=here-&gt;JDVAL_%(#row/name)_%(#column/name) *(s-&gt;real);\n"/>
<admst:text select="reverse(@jacobianklass[exists(@jcontribution[#modifyd=1])])" format="  if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required) *(here-&gt;PTR_J_%(#row/name)_%(#column/name)+1)+=here-&gt;JDVAL_%(#row/name)_%(#column/name) *(s-&gt;imag);\n"/>
    } /* End of MOSFET Instance */
  } /* End of Model Instance */
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)pzld.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng13"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)pzld.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEtrunc.c.xml" ?>
    <admst:template match="code:ng14">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

#define ccap (qcap+1)
static void my$(module)CKTterr(int qcap, CKTcircuit *ckt, double *timeStep)
{ 
    double volttol;
    double chargetol;
    double tol;
    double del;
    double diff[8];
    double deltmp[8];
    double factor=0;
    int i;
    int j;
    static double gearCoeff[] = {
        .5,
        .2222222222,
        .1363636364,
        .096,
        .07299270073,
        .05830903790
    };
    static double trapCoeff[] = {
        .5,
        .08333333333
    };

    volttol = ckt-&gt;CKTabstol + ckt-&gt;CKTreltol * 
            MAX( fabs(*(ckt-&gt;CKTstate0+ccap)), fabs(*(ckt-&gt;CKTstate1+ccap)));
            
    chargetol = MAX(fabs(*(ckt-&gt;CKTstate0 +qcap)),fabs(*(ckt-&gt;CKTstate1+qcap)));
    chargetol = ckt-&gt;CKTreltol * MAX(chargetol,ckt-&gt;CKTchgtol)/ckt-&gt;CKTdelta;
    tol = MAX(volttol,chargetol);
    /* now divided differences */
    for(i=ckt-&gt;CKTorder+1;i&gt;=0;i--) {
        diff[i] = *(ckt-&gt;CKTstates[i] + qcap);
    }
    for(i=0 ; i &lt;= ckt-&gt;CKTorder ; i++) {
        deltmp[i] = ckt-&gt;CKTdeltaOld[i];
    }
    j = ckt-&gt;CKTorder;
    for (;;) {
        for(i=0;i &lt;= j;i++) {
            diff[i] = (diff[i] - diff[i+1])/deltmp[i];
        }
        if (--j &lt; 0) break;
        for(i=0;i &lt;= j;i++) {
            deltmp[i] = deltmp[i+1] + ckt-&gt;CKTdeltaOld[i];
        }
    }
    switch(ckt-&gt;CKTintegrateMethod) {
        case GEAR:
            factor = gearCoeff[ckt-&gt;CKTorder-1];
            break;

        case TRAPEZOIDAL:
            factor = trapCoeff[ckt-&gt;CKTorder - 1] ;
            break;
    }
    del = ckt-&gt;CKTtrtol * tol/MAX(ckt-&gt;CKTabstol,factor * fabs(diff[0]));
    if(ckt-&gt;CKTorder == 2) {
        del = sqrt(del);
    } else if (ckt-&gt;CKTorder &gt; 2) {
        del = exp(log(del)/ckt-&gt;CKTorder);
    }
    *timeStep = MIN(*timeStep,del);
    return;
}


int $(module)trunc(GENmodel *inModel, CKTcircuit *ckt, double *timeStep)
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;

#ifdef STEPDEBUG
    double debugtemp;
#endif /* STEPDEBUG */  
  
  for ( ; model != NULL; model = model-&gt;$(module)nextModel )
  {
    /* loop through all the instances of the model */
    for (here = model-&gt;$(module)instances; here != NULL ; here = here-&gt;$(module)nextInstance)
    {
#ifdef STEPDEBUG
            debugtemp = *timeStep;
#endif /* STEPDEBUG */   
 
    <admst:for-each select="@npncontributionklass[exists(@kcontribution[#modifyd=1])]">
            my$(module)CKTterr(here-&gt;state_%(pnode/name)_%(nnode/name), ckt, timeStep);
    </admst:for-each>
    
 
#ifdef STEPDEBUG
            if(debugtemp != *timeStep)
	    {  printf("device %s reduces step from %g to %g\\n",
                       here-&gt;$(module)name,debugtemp,*timeStep);
            }
#endif /* STEPDEBUG */
   
    } /* End of Instance */
  } /* End of Model */
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)trunc.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng14"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)trunc.c: file created\n"/>
</admst:for-each>

<?escript name="ngspice_1_0_1/ngspiceMODULEsetup.c.xml" ?>
<admst:template match="code:ng15">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

//fixme!!! redundant
#define max(x,y)        (((x)&gt;(y))?(x):(y))
#define min(x,y)       (((x)&lt;(y))?(x):(y))
#define logE(x)         log(x)

int $(module)setup (SMPmatrix *matrix, GENmodel *inModel, CKTcircuit *ckt, int *states)
     /* load the $(module) device structure with those pointers needed later 
      * for fast matrix loading 
      */
{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance *here;
typedef int FP1(CKTcircuit *ckt, CKTnode **node, IFuid basename, char *suffix);
typedef double * FP2(SMPmatrix *Matrix, int Row, int Col);
  FP1 *myCKTmkVolt  = get_$(module)_info()->mkn;
  FP2 *mySMPmakeElt = get_$(module)_info()->mkj;
  
  /*  loop through all the $(module) device models */
  for ( ;model != NULL ;model = model-&gt;$(module)nextModel )
  {
<admst:for-each select="modulevariablep[#parametertype!='instance' and isparameter='yes']">
<admst:if test="default[exists(@exfunction[#class='builtin'])]">
<admst:text format="{\n"/>
<admst:text select="default/@exfunction" format="double __%(fgetname(.)/[name='fgetname']/value)_%(position()-1)=0.0;\n"/>
<admst:apply-templates select="default" match="function:assignment"/>
</admst:if>
    if(model-&gt;%(name)_Given == FALSE) model-&gt;%(name)=%(estringifynoprobe(default)/[name='ret']/value);
<admst:text test="default[exists(@exfunction[#class='builtin'])]" format="}\n"/>
</admst:for-each>
    for ( here = model-&gt;$(module)instances ;here != NULL ; here = here-&gt;$(module)nextInstance )
    {
<admst:for-each select="modulevariablep[#parametertype='instance' and isparameter='yes']">
<admst:if test="default[exists(@exfunction[#class='builtin'])]">
<admst:text format="{\n"/>
<admst:text select="default/@exfunction" format="double __%(fgetname(.)/[name='fgetname']/value)_%(position()-1)=0.0;\n"/>
<admst:apply-templates select="default" match="function:assignment"/>
</admst:if>
    if(here-&gt;%(name)_Given == FALSE) here-&gt;%(name)=%(estringifynoprobe(default)/[name='ret']/value);
<admst:text test="default[exists(@exfunction[#class='builtin'])]" format="}\n"/>
</admst:for-each>
<admst:if test="modulenode[location='internal']">
      /* Internal Nodes */
      {
<admst:for-each select="modulenode[location='internal']">
<admst:variable name="info" string="no info"/>
<admst:for-each select="attribute[name='info']">
<admst:variable name="info" string="%(value)"/>
</admst:for-each>
        here-&gt;%(name)Node = -1;
</admst:for-each>
      }
</admst:if>
      /* set states */
<admst:for-each select="@npncontributionklass[exists(@kcontribution[#modifyd=1])]">
      here-&gt;state_%(pnode/name)_%(nnode/name) = *states; *states += 2;
</admst:for-each>
      /* set Sparse Matrix Pointers */
<admst:for-each select="reverse(@jacobianklass)">
      here-&gt;PTR_J_%(#row/name)_%(#column/name)_required=1;
</admst:for-each>

      /* Internal Nodes */
      {
        int error;
        CKTnode *tmp;
<admst:for-each select="modulenode[location='internal']">
<admst:variable name="info" string="no info"/>
<admst:for-each select="attribute[name='info']">
<admst:variable name="info" string="%(value)"/>
</admst:for-each>
        if(here-&gt;%(name)Node == -1)
        {
          error=myCKTmkVolt(ckt,&amp;tmp,here-&gt;$(module)name,&quot;$info&quot;);
          if(error) return(error);
          here-&gt;%(name)Node = tmp-&gt;number;
        }
</admst:for-each>
      }
<admst:for-each select="reverse(@jacobianklass)">
        if(here-&gt;PTR_J_%(#row/name)_%(#column/name)_required==1)
        {
          here-&gt;PTR_J_%(#row/name)_%(#column/name)=mySMPmakeElt(matrix,here-&gt;%(#row/name)Node,here-&gt;%(#column/name)Node);
        }
</admst:for-each>

    }
  }
  return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)setup.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng15"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)setup.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEdel.c.xml" ?>
    <admst:template match="code:ng16">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)delete(GENmodel *inModel, IFuid name, GENinstance **inInst)

{
  register $(module)model *model = ($(module)model*)inModel;
  register $(module)instance **fast =($(module)instance**)inInst;
  
  $(module)instance **prev = NULL;
  $(module)instance *here;
  
  for ( ; model ; model = model-&gt;$(module)nextModel ) {
      prev = &amp;(model-&gt;$(module)instances);  
      for (here = *prev; here ; here  = *prev) {
          if(here-&gt;$(module)name == name || (fast &amp;&amp; here==*fast) ) {
	      *prev = here-&gt;$(module)nextInstance;
	      myFREE(here);
	      return(OK);
	      }
         
    } 
  } 
  return(E_NODEV);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)del.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng16"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)del.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEmdel.c.xml" ?>
    <admst:template match="code:ng17">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

int $(module)mDelete(GENmodel **inModel, IFuid modname, GENmodel *kill)

{
  register $(module)model **model = ($(module)model**)inModel;
  register $(module)model *modfast =($(module)model*)kill;
  $(module)instance *here;
  $(module)instance *prev = NULL;
  $(module)model **oldmod;
  
  oldmod = model;
  for ( ; *model ; model = &amp;((*model)-&gt;$(module)nextModel)) {
      if ((*model)-&gt;$(module)modName == modname ||
          (modfast &amp;&amp; *model == modfast))
	  goto delgot;
      oldmod = model;   
  } 
  return(E_NOMOD);
  
  delgot:
    *oldmod = (*model)-&gt;$(module)nextModel; /* cut deleted device out of list */
    for (here = (*model)-&gt;$(module)instances; here; here = here-&gt;$(module)nextInstance)
    {    if(prev) myFREE(prev);
         prev = here;
    }
    if(prev) myFREE(prev);
    myFREE(*model);
    return(OK);
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)mdel.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng17"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)mdel.c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULEdest.c.xml" ?>
    <admst:template match="code:ng18">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

void $(module)destroy(GENmodel **inModel)

{
  register $(module)model **model = ($(module)model**)inModel;
  register $(module)instance *here;
  $(module)instance *prev = NULL;
  $(module)model *mod = *model;
  $(module)model *oldmod = NULL;
  
  for ( ; mod ; mod = mod-&gt;$(module)nextModel ) {
      if (oldmod) myFREE(oldmod);
      oldmod = mod;
      prev = ($(module)instance *)NULL;  
      for (here = mod-&gt;$(module)instances; here ; here = here-&gt;$(module)nextInstance) {
          if(prev) myFREE(prev);
	  prev = here;
	  }
          if(prev) myFREE(prev);
    } 
    if(oldmod) myFREE(oldmod);
    *model = NULL;
  return;
}

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value)dest.c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng18"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value)dest.c: file created\n"/>
    </admst:for-each>

<?escript name="ngspice_1_0_1/ngspiceMODULE.c.xml" ?>
<admst:template match="code:ng20">
<admst:variable name="module" string="%(attribute[name='ngspicename']/value)"/>

#include &quot;$(module)itf.h&quot;

<admst:text format="IFparm $(module)pTable[] = {\n"/>
<admst:join select="modulevariablep[#parametertype='instance' and isparameter='yes']" separator=",\n">
<admst:choose>
<admst:when test="[type='real']">
<admst:text format=" IOP(&quot;%(lower-case(name))&quot;,$(module)_instance_%(name),IF_REAL,&quot;%(name)&quot;)"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format=" IOP(&quot;%(lower-case(name))&quot;,$(module)_instance_%(name),IF_INTEGER,&quot;%(name)&quot;)"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
</admst:join>
<admst:text format="\n};\n"/>
<admst:text format="IFparm $(module)mPTable[] = {\n"/>
<admst:join select="modulevariablep[#parametertype!='instance' and isparameter='yes']" separator=",\n">
<admst:choose>
<admst:when test="[type='real']">
<admst:text format=" IOP(&quot;%(lower-case(name))&quot;,$(module)_model_%(name),IF_REAL,&quot;%(name)&quot;)"/>
</admst:when>
<admst:when test="[type='integer']">
<admst:text format=" IOP(&quot;%(lower-case(name))&quot;,$(module)_model_%(name),IF_INTEGER,&quot;%(name)&quot;)"/>
</admst:when>
<admst:otherwise>
<admst:fatal format="parameter of type 'string' not supported\n"/>
</admst:otherwise>
</admst:choose>
</admst:join>
<admst:text format="\n};\n"/>

char *$(module)names[] = {
<admst:join select="modulenode[location!='ground']" separator=",\n">
<admst:choose>
<admst:when test="attribute[name='name']">
<admst:text select="attribute[name='name']" format=" &quot;%(value)&quot;"/>
</admst:when>
<admst:otherwise>
<admst:text format=" &quot;%(name)&quot;"/>
</admst:otherwise>
</admst:choose>
</admst:join>
};

int $(module)nSize = NUMELEMS($(module)names);
int $(module)pTSize = NUMELEMS($(module)pTable);
int $(module)mPTSize = NUMELEMS($(module)mPTable);
int $(module)iSize = sizeof($(module)instance);
int $(module)mSize = sizeof($(module)model);

</admst:template>
    <admst:for-each select="/@module">
      <admst:open file="%(attribute[name='ngspicename']/value).c">
        <admst:text format="/*** created by: %(/fullname) - %(/currentdate) ***/\n"/>
        <admst:apply-templates select="." match="code:ng20"/>
      </admst:open>
      <admst:message format="%(attribute[name='ngspicename']/value).c: file created\n"/>
    </admst:for-each>
<?escript name="ngspice_1_0_1/ngspiceMODULE.hxx.xml" ?>
    <admst:template match="c:math_h">
/* arithmetics */
#define EXP90 1.220403294317841e+039
#define m00_hypot(v00,x,y)      v00 = sqrt((x)*(x)+(y)*(y));
#define m10_hypot(v10,v00,x,y)  v10 = (x)/(v00);
#define m11_hypot(v11,v00,x,y)  v11 = (y)/(v00);
#define m00_max(v00,x,y)        v00 = ((x)&gt;(y))?(x):(y);
#define m10_max(v10,v00,x,y)    v10 = ((x)&gt;(y))?1.0:0.0;
#define m11_max(v11,v00,x,y)    v11 = ((x)&gt;(y))?0.0:1.0;
#define m00_min(v00,x,y)        v00 = ((x)&lt;(y))?(x):(y);
#define m10_min(v10,v00,x,y)    v10 = ((x)&lt;(y))?1.0:0.0;
#define m11_min(v11,v00,x,y)    v11 = ((x)&lt;(y))?0.0:1.0;
#define m00_pow(v00,x,y)        v00 = pow(x,y);
#define m10_pow(v10,v00,x,y)    v10 = (x==0.0)?0.0:(v00)*(y)/(x);
#define m11_pow(v11,v00,x,y)    v11 = (x==0.0)?0.0:(log(x)*(v00));
#define m00_div(v00,v10,x,y)    double v10=1/(y); double v00=(x)*v10;
#define m10_div(v10,v00,vv,x,y)
#define m11_div(v11,v00,vv,x,y) double v11 = -v00*vv;
#define m00_mult(v00,v10,v11,x,y) double v10=(x); double v11=(y); double v00=v10*v11;
#define m00_add(v00,x,y)        double v00=(x)+(y);
#define m00_cos(v00,x)          v00 = cos(x);
#define m10_cos(v10,v00,x)      v10 = (-sin(x));
#define m00_sin(v00,x)          v00 = sin(x);
#define m10_sin(v10,v00,x)      v10 = (cos(x));
#define m00_tan(v00,x)          v00 = tan(x);
#define m10_tan(v10,v00,x)      v10 = (1.0/cos(x)/cos(x));
#define m00_cosh(v00,x)         v00 = cosh(x);
#define m10_cosh(v10,v00,x)     v10 = (sinh(x));
#define m00_sinh(v00,x)         v00 = sinh(x);
#define m10_sinh(v10,v00,x)     v10 = (cosh(x));
#define m00_tanh(v00,x)         v00 = tanh(x);
#define m10_tanh(v10,v00,x)     v10 = (1.0/cosh(x)/cosh(x));
#define m00_acos(v00,x)         v00 = acos(x);
#define m10_acos(v10,v00,x)     v10 = (-1.0/sqrt(1-x*x));
#define m00_asin(v00,x)         v00 = asin(x);
#define m10_asin(v10,v00,x)     v10 = (+1.0/sqrt(1-x*x));
#define m00_atan(v00,x)         v00 = atan(x);
#define m10_atan(v10,v00,x)     v10 = (+1.0/(1+x*x));
#define m00_logE(v00,x)         v00 = log(x);
#define m10_logE(v10,v00,x)     v10 = (1.0/x);
#define m00_log10(v00,x)        v00 = log10(x);
#define m10_log10(v10,v00,x)    v10 = (1.0/x/log(10));
#define m00_sqrt(v00,x)         v00 = sqrt(x);
#define m10_sqrt(v10,v00,x)     v10 = (1.0/((v00&gt;0)?(2.0*v00):1.0E+38));
#define m00_fabs(v00,x)         v00 = fabs(x);
#define m10_fabs(v10,v00,x)     v10 = (((x)&gt;=0)?(+1.0):(-1.0));
#define m00_exp(v00,x)          v00 = exp(x);
#define m10_exp(v10,v00,x)      v10 = v00;
#define m00_abs(v00)            ((v00)&lt;(0)?(-(v00)):(v00))
#define m00_limexp(v00,x)       v00 = ((x)&lt;90.0?exp(x):EXP90*(x-89.0));
#define m10_limexp(v10,v00,x)   v10 = ((x)&lt;90.0?(v00):EXP90);

#define m20_logE(v00)         (-1.0/v00/v00)
#define m20_exp(v00)          exp(v00)
#define m20_limexp(v00)       ((v00)&lt;90.0?exp(v00):0.0)
#define m20_sqrt(v00)         (-0.25/(v00)/sqrt(v00))
#define m20_fabs(v00)         0.0

</admst:template>
    <admst:template match="wrapper">
/*wrapper*/
#define pModel model
#define pInst here
#define mint_get_circuit_tempK() _circuit_temp
#define _DDT(q) q
#define _DDX
#define _DERIVATEFORDDX
<admst:if test="/@module/modulevariablep[exists(@protoinstance[prototype/#derivate='yes']) and #insource=1]">
#define _DERIVATE2
<admst:variable name="requiredderivateforddx" string="yes"/>
</admst:if>
</admst:template>
    <admst:template match="c:functionp:math_h">
inline double _cos(double arg)             { return  cos(arg); }
inline double _d0_cos(double arg)          { return (-sin(arg)); }
inline double _sin(double arg)             { return  sin(arg); }
inline double _d0_sin(double arg)          { return (cos(arg)); }
inline double _tan(double arg)             { return  tan(arg); }
inline double _d0_tan(double arg)          { return (1.0/cos(arg)/cos(arg)); }
inline double _cosh(double arg)            { return  cosh(arg); }
inline double _d0_cosh(double arg)         { return (sinh(arg)); }
inline double _sinh(double arg)            { return  sinh(arg); }
inline double _d0_sinh(double arg)         { return (cosh(arg)); }
inline double _tanh(double arg)            { return  tanh(arg); }
inline double _d0_tanh(double arg)         { return (1.0/cosh(arg)/cosh(arg)); }
inline double _acos(double arg)            { return  acos(arg); }
inline double _d0_acos(double arg)         { return (-1.0/sqrt(1-arg*arg)); }
inline double _asin(double arg)            { return  asin(arg); }
inline double _d0_asin(double arg)         { return (+1.0/sqrt(1-arg*arg)); }
inline double _atan(double arg)            { return  atan(arg); }
inline double _d0_atan(double arg)         { return (+1.0/(1+arg*arg)); }
inline double _logE(double arg)            { return  log(arg); }
inline double _d0_logE(double arg)         { return (1.0/arg); }
inline double _log10(double arg)           { return  log10(arg); }
inline double _d0_log10(double arg)        { return (1.0/arg/log(10)); }
inline double _exp(double arg)             { return  exp(arg); }
inline double _d0_exp(double arg)          { return exp(arg); }
inline double _sqrt(double arg)            { return  sqrt(arg); }
inline double _d0_sqrt(double arg)         { return (1.0/sqrt(arg)/2.0); }
inline double _abs(double arg)             { return  fabs(arg); }
inline double _d0_abs(double arg)          { return (((arg)&gt;=0)?(+1.0):(-1.0)); }

inline double _hypot(double x,double y)    { return sqrt((x)*(x)+(y)*(y)); }
inline double _d0_hypot(double x,double y) { return (x)/sqrt((x)*(x)+(y)*(y)); }
inline double _d1_hypot(double x,double y) { return (y)/sqrt((x)*(x)+(y)*(y)); }

inline double _max(double x,double y)      { return ((x)&gt;(y))?(x):(y); }
inline double _d0_max(double x,double y)   { return ((x)&gt;(y))?1.0:0.0; }
inline double _d1_max(double x,double y)   { return ((x)&gt;(y))?0.0:1.0; }

inline double _min(double x,double y)      { return ((x)&lt;(y))?(x):(y); }
inline double _d0_min(double x,double y)   { return ((x)&lt;(y))?1.0:0.0; }
inline double _d1_min(double x,double y)   { return ((x)&lt;(y))?0.0:1.0; }

inline double _pow(double x,double y)      { return pow(x,y); }
inline double _d0_pow(double x,double y)   { return (x==0.0)?0.0:((y/x)*pow(x,y)); }
inline double _d1_pow(double x,double y)   { return (x==0.0)?0.0:((log(x)/exp(0.0))*pow(x,y)); }

#define _limexp(arg)    _exp(val,arg)
#define _d_limexp(arg)  _d_exp(val,dval,arg)

</admst:template>
    <!-- compute node arguments of noise routines -->
    <admst:template match="noisebranch">
      <admst:variable name="n1" string=""/>
      <admst:choose>
        <admst:when test="[nnode/location='ground']">
          <admst:return name="noisebranch" string="%(pnode/name),%(pnode/name)"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="noisebranch" string="%(pnode/name),%(nnode/name)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <!-- compute range of variables -->
    <admst:template match="variable:range:foreach">
      <admst:choose>
        <admst:when test="infexpr[[datatypename='number']/scalingunit!='0']">
          <admst:apply-templates select="infexpr" match="hxx%(datatypename)"/>
          <admst:variable name="lower" string="$e"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="lower" string="-inf"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="supexpr[[datatypename='number']/scalingunit!='0']">
          <admst:apply-templates select="supexpr" match="hxx%(datatypename)"/>
          <admst:variable name="upper" string="$e"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="upper" string="inf"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[type='include']">
          <admst:variable name="rangetype" string="from"/>
        </admst:when>
        <admst:when test="[type='exclude']">
          <admst:variable name="rangetype" string="exclude"/>
        </admst:when>
      </admst:choose>
      <admst:variable name="interval" string="$lower:$upper"/>
      <admst:choose>
        <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_include']">
          <admst:variable name="interval" string="[$interval]"/>
        </admst:when>
        <admst:when test="[infboundtype='range_bound_include' and supboundtype='range_bound_exclude']">
          <admst:variable name="interval" string="[$interval)"/>
        </admst:when>
        <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_include']">
          <admst:variable name="interval" string="($interval]"/>
        </admst:when>
        <admst:when test="[infboundtype='range_bound_exclude' and supboundtype='range_bound_exclude']">
          <admst:variable name="interval" string="($interval)"/>
        </admst:when>
      </admst:choose>
      <admst:text format="$rangetype $interval "/>
    </admst:template>
    <admst:template match="variable:range">
      <admst:choose>
        <admst:when test="[exists(range)]">
          <admst:text format="        &quot;"/>
          <admst:apply-templates select="range" match="variable:range:foreach"/>
          <admst:text format="&quot;"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="        NULL"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="ddx">
      <admst:apply-templates select="." match="hxx%(datatypename)"/>
    </admst:template>
    <admst:template match="ddxname">
      <admst:return name="ddxname" string="%(name)_%($pprobe/nature/access)%($pprobe/pnode/name)_%($pprobe/nnode/name)_%($qprobe/nature/access)%($qprobe/pnode/name)_%($qprobe/nnode/name)"/>
    </admst:template>
    <admst:template match="dxname">
      <admst:return name="dxname" string="%(name)_%($pprobe/nature/access)%($pprobe/pnode/name)_%($pprobe/nnode/name)"/>
    </admst:template>
    <admst:template match="hxxvariable">
      <admst:choose>
        <admst:when test="prototype[#parametertype='model']">
          <admst:variable name="e" string="pModel-&gt;%(name)"/>
        </admst:when>
        <admst:when test="prototype[#parametertype='instance']">
          <admst:variable name="e" string="pInst-&gt;%(name)"/>
        </admst:when>
        <admst:when test="prototype[isparameter='no' and #scope='global_instance']">
          <admst:variable name="e" string="pInst-&gt;%(name)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" path="name"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="ep" string="0.0"/>
      <admst:if test="prototype[#insource=1]">
        <admst:variable test="prototype[exists(@vpprobe[$pprobe/nature=nature and $pprobe/pnode=pnode and $pprobe/nnode=nnode])]" name="ep" string="%(name)_%($pprobe/nature/access)%($pprobe/pnode/name)_%($pprobe/nnode/name)"/>
      </admst:if>
      <admst:if test="$qprobe">
        <admst:variable name="eq" string="0.0"/>
        <admst:if test="prototype[#insource=1]">
          <admst:variable test="prototype[exists(@vpprobe[$qprobe/nature=nature and $qprobe/pnode=pnode and $qprobe/nnode=nnode])]" name="eq" string="%(name)_%($qprobe/nature/access)%($qprobe/pnode/name)_%($qprobe/nnode/name)"/>
        </admst:if>
        <admst:variable name="epq" string="0.0"/>
        <admst:if test="prototype[#insource=1]">
          <admst:if test="prototype[exists(@vpprobe[$pprobe/nature=nature and $pprobe/pnode=pnode and $pprobe/nnode=nnode])]">
            <admst:variable test="prototype[exists(@vpprobe[$qprobe/nature=nature and $qprobe/pnode=pnode and $qprobe/nnode=nnode])]" name="epq" path="ddxname(.)/[name='ddxname']/value"/>
          </admst:if>
        </admst:if>
      </admst:if>
    </admst:template>
    <admst:template match="hxxprobe">
      <admst:choose>
        <admst:when test="nnode[location!='ground']">
          <admst:variable name="e" string="(voltages(%(pnode/name))-voltages(%(nnode/name)))"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" string="voltages(%(pnode/name))"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[$pprobe/nature=nature and $pprobe/pnode=pnode and $pprobe/nnode=nnode]">
          <admst:variable name="ep" string="1.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" string="0.0"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$qprobe">
        <admst:choose>
          <admst:when test="[$qprobe/nature=nature and $qprobe/pnode=pnode and $qprobe/nnode=nnode]">
            <admst:variable name="eq" string="1.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" string="0.0"/>
          </admst:otherwise>
        </admst:choose>
        <admst:variable name="epq" string="0.0"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxnode">
      <admst:fatal format="module node not expected here ... %(name)\n"/>
      <admst:fatal format="module node not expected here ... %(name)\n"/>
      <admst:if test="$qprobe">
        <admst:fatal format="module node not expected here ... %(name)\n"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxstring">
      <admst:variable name="e" string="&quot;%(value)&quot;"/>
      <admst:variable name="ep" string="0.0"/>
      <admst:if test="$qprobe">
        <admst:variable name="eq" string="0.0"/>
        <admst:variable name="epq" string="0.0"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxnumber">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:variable name="e" string="%(value)"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:variable name="e" string="(%(value)*1.0e+18)"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:variable name="e" string="(%(value)*1.0e+15)"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:variable name="e" string="(%(value)*1.0e+12)"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:variable name="e" string="(%(value)*1.0e+9)"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:variable name="e" string="(%(value)*1.0e+6)"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:variable name="e" string="(%(value)*1.0e+3)"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:variable name="e" string="(%(value)*1.0e+2)"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:variable name="e" string="(%(value)*1.0e+1)"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:variable name="e" string="(%(value)*1.0e-1)"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:variable name="e" string="(%(value)*1.0e-2)"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:variable name="e" string="(%(value)*1.0e-3)"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:variable name="e" string="(%(value)*1.0e-6)"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:variable name="e" string="(%(value)*1.0e-9)"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:variable name="e" string="(%(value)*1.0e-10)"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:variable name="e" string="(%(value)*1.0e-12)"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:variable name="e" string="(%(value)*1.0e-15)"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:variable name="e" string="(%(value)*1.0e-18)"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="ep" string="0.0"/>
      <admst:if test="$qprobe">
        <admst:variable name="eq" string="0.0"/>
        <admst:variable name="epq" string="0.0"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxunary">
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:choose>
            <admst:otherwise>
              <admst:apply-templates select="arguments[1]" match="ddx"/>
              <admst:variable name="e" string="(+$e)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:choose>
            <admst:otherwise>
              <admst:apply-templates select="arguments[1]" match="ddx"/>
              <admst:variable name="e" string="(-$e)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:choose>
            <admst:otherwise>
              <admst:apply-templates select="arguments[1]" match="ddx"/>
              <admst:variable name="e" string="(!$e)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:choose>
            <admst:otherwise>
              <admst:apply-templates select="arguments[1]" match="ddx"/>
              <admst:variable name="e" string="(~$e)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="%(name):function not handled\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[$e='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$ep='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:choose>
            <admst:when test="[name='plus']">
              <admst:variable name="ep" string="(+$ep)"/>
            </admst:when>
            <admst:when test="[name='minus']">
              <admst:variable name="ep" string="(-$ep)"/>
            </admst:when>
            <admst:when test="[name='not']">
              <admst:variable name="ep" string="(!$ep)"/>
            </admst:when>
            <admst:when test="[name='bw_not']">
              <admst:variable name="ep" string="(~$ep)"/>
            </admst:when>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$qprobe">
        <admst:choose>
          <admst:when test="[$e='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$eq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[name='plus']">
                <admst:variable name="eq" string="(+$eq)"/>
              </admst:when>
              <admst:when test="[name='minus']">
                <admst:variable name="eq" string="(-$eq)"/>
              </admst:when>
              <admst:when test="[name='not']">
                <admst:variable name="eq" string="(!$eq)"/>
              </admst:when>
              <admst:when test="[name='bw_not']">
                <admst:variable name="eq" string="(~$eq)"/>
              </admst:when>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
        <admst:variable name="epq" string="0.0"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxbinary">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="xq" string="$eq"/>
      <admst:variable name="xpq" string="$epq"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" string="$e"/>
      <admst:variable name="yp" string="$ep"/>
      <admst:variable name="yq" string="$eq"/>
      <admst:variable name="ypq" string="$epq"/>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="e" string="($x+$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="e" string="($x-$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="e" string="($x*$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:otherwise>
              <admst:variable name="e" string="($x/$y)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" string="($x%(bname(.)/[name='bname']/value)$y)"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[name='addp']">
          <admst:choose>
            <admst:when test="[$xp='0.0' and $yp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0']">
              <admst:variable name="ep" string="$yp"/>
            </admst:when>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" string="$xp"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" string="($xp+$yp)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='addm']">
          <admst:choose>
            <admst:when test="[$xp='0.0' and $yp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0']">
              <admst:variable name="ep" string="(-$yp)"/>
            </admst:when>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" string="$xp"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" string="($xp-$yp)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multtime']">
          <admst:choose>
            <admst:when test="[$x='0.0' and $y='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0' and $yp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0' and $yp='1.0']">
              <admst:variable name="ep" string="($x)"/>
            </admst:when>
            <admst:when test="[$xp='1.0' and $yp='0.0']">
              <admst:variable name="ep" string="($y)"/>
            </admst:when>
            <admst:when test="[$xp='0.0']">
              <admst:variable name="ep" string="($x*$yp)"/>
            </admst:when>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" string="$xp*$y"/>
            </admst:when>
            <admst:when test="[$xp='1.0' and $yp='1.0']">
              <admst:variable name="ep" string="($x+$y)"/>
            </admst:when>
            <admst:when test="[$xp='1.0']">
              <admst:variable name="ep" string="($y+($yp*$x))"/>
            </admst:when>
            <admst:when test="[$yp='1.0']">
              <admst:variable name="ep" string="(($xp*$y)+$x)"/>
            </admst:when>
            <admst:when test="[$x='1.0']">
              <admst:variable name="ep" string="$yp"/>
            </admst:when>
            <admst:when test="[$y='1.0']">
              <admst:variable name="ep" string="$xp"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" string="(($xp*$y)+($x*$yp))"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='multdiv']">
          <admst:choose>
            <admst:when test="[$x='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0' and $yp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$x='1.0']">
              <admst:choose>
                <admst:when test="[$yp='1.0']">
                  <admst:variable name="ep" string="(-1/$y/$y)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="ep" string="(-$yp/$y/$y)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:when>
            <admst:when test="[$xp='0.0']">
              <admst:choose>
                <admst:when test="[$yp='1.0']">
                  <admst:variable name="ep" string="(-$x/$y/$y)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="ep" string="(-$x*$yp/$y/$y)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:when>
            <admst:when test="[$xp='1.0']">
              <admst:choose>
                <admst:when test="[$yp='0.0']">
                  <admst:variable name="ep" string="(1/$y)"/>
                </admst:when>
                <admst:when test="[$yp='1.0']">
                  <admst:variable name="ep" string="(($y-$x)/$y/$y)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="ep" string="(($y-($x*$yp))/$y/$y)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:when>
            <admst:otherwise>
              <admst:choose>
                <admst:when test="[$y='1.0']">
                  <admst:variable name="ep" string="$xp"/>
                </admst:when>
                <admst:when test="[$yp='0.0']">
                  <admst:variable name="ep" string="($xp/$y)"/>
                </admst:when>
                <admst:when test="[$yp='1.0']">
                  <admst:variable name="ep" string="(($xp*$y-$x)/$y/$y)"/>
                </admst:when>
                <admst:otherwise>
                  <admst:variable name="ep" string="(($xp*$y-$x*$yp)/$y/$y)"/>
                </admst:otherwise>
              </admst:choose>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" string="0.0"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$qprobe">
        <admst:choose>
          <admst:when test="[name='addp']">
            <admst:choose>
              <admst:when test="[$xq='0.0' and $yq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="eq" string="$yq"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" string="$xq"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="($xq+$yq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='addm']">
            <admst:choose>
              <admst:when test="[$xq='0.0' and $yq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="eq" string="(-$yq)"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" string="$xq"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="($xq-$yq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multtime']">
            <admst:choose>
              <admst:when test="[$x='0.0' and $y='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0' and $yq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0' and $yq='1.0']">
                <admst:variable name="eq" string="($x)"/>
              </admst:when>
              <admst:when test="[$xq='1.0' and $yq='0.0']">
                <admst:variable name="eq" string="($y)"/>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="eq" string="($x*$yq)"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" string="$xq*$y"/>
              </admst:when>
              <admst:when test="[$xq='1.0' and $yq='1.0']">
                <admst:variable name="eq" string="($x+$y)"/>
              </admst:when>
              <admst:when test="[$xq='1.0']">
                <admst:variable name="eq" string="($y+($yq*$x))"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" string="(($xq*$y)+$x)"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:variable name="eq" string="$yq"/>
              </admst:when>
              <admst:when test="[$y='1.0']">
                <admst:variable name="eq" string="$xq"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="(($xq*$y)+($x*$yq))"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multdiv']">
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0' and $yq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$x='1.0']">
                <admst:choose>
                  <admst:when test="[$yq='1.0']">
                    <admst:variable name="eq" string="(-1/$y/$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="eq" string="(-$yq/$y/$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:choose>
                  <admst:when test="[$yq='1.0']">
                    <admst:variable name="eq" string="(-$x/$y/$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="eq" string="(-$x*$yq/$y/$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:when test="[$xq='1.0']">
                <admst:choose>
                  <admst:when test="[$yq='0.0']">
                    <admst:variable name="eq" string="(1/$y)"/>
                  </admst:when>
                  <admst:when test="[$yq='1.0']">
                    <admst:variable name="eq" string="(($y-$x)/$y/$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="eq" string="(($y-($x*$yq))/$y/$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:when>
              <admst:otherwise>
                <admst:choose>
                  <admst:when test="[$y='1.0']">
                    <admst:variable name="eq" string="$xq"/>
                  </admst:when>
                  <admst:when test="[$yq='0.0']">
                    <admst:variable name="eq" string="($xq/$y)"/>
                  </admst:when>
                  <admst:when test="[$yq='1.0']">
                    <admst:variable name="eq" string="(($xq*$y-$x)/$y/$y)"/>
                  </admst:when>
                  <admst:otherwise>
                    <admst:variable name="eq" string="(($xq*$y-$x*$yq)/$y/$y)"/>
                  </admst:otherwise>
                </admst:choose>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" string="0.0"/>
          </admst:otherwise>
        </admst:choose>
        <admst:choose>
          <admst:when test="[name='addp']">
            <admst:variable name="t1" string="+$xpq"/>
            <admst:variable name="t2" string="+$ypq"/>
            <admst:variable name="epq" string="$t1$t2"/>
            <admst:choose>
              <admst:when test="[$epq='']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="epq" string="($epq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='addm']">
            <admst:variable name="t1" string="+$xpq"/>
            <admst:variable name="t2" string="-$ypq"/>
            <admst:variable name="epq" string="$t1$t2"/>
            <admst:choose>
              <admst:when test="[$epq='']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="epq" string="($epq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multtime']">
            <admst:variable name="t1" string="+$xpq*$y"/>
            <admst:variable name="t2" string="+$xp*$yq"/>
            <admst:variable name="t3" string="+$xq*$yp"/>
            <admst:variable name="t4" string="+$x*$ypq"/>
            <admst:variable name="epq" string="$t1$t2$t3$t4"/>
            <admst:choose>
              <admst:when test="[$eq='']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="($eq)"/>
              </admst:otherwise>
            </admst:choose>
            <admst:choose>
              <admst:when test="[$epq='']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="epq" string="($epq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='multdiv']">
            <admst:variable name="epq" string="($xpq/$y-($xp*$yq+$xq*$yp+$x*$ypq)/$y/$y+2*$x*$yp*$yq/$y/$y/$y)"/>
          </admst:when>
        </admst:choose>
      </admst:if>
    </admst:template>
    <admst:template match="hxxternary">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" string="$e"/>
      <admst:variable name="yp" string="$ep"/>
      <admst:variable name="yq" string="$eq"/>
      <admst:apply-templates select="arguments[3]" match="ddx"/>
      <admst:variable name="z" string="$e"/>
      <admst:variable name="zp" string="$ep"/>
      <admst:variable name="zq" string="$eq"/>
      <admst:variable name="e" string="($x?$y:$z)"/>
      <admst:variable name="ep" string="($x?$yp:$zp)"/>
      <admst:if test="$qprobe">
        <admst:variable name="ep" string="($x?$yp:$zp)"/>
        <admst:variable name="epq" string="fixme"/>
      </admst:if>
    </admst:template>
    <admst:template match="hxxnary">
      <admst:choose>
        <admst:when test="[name='absdelay']">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="e" string="$e"/>
        </admst:when>
        <admst:when test="[name='ddt']">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" string="$e"/>
          <admst:variable name="xp" string="$ep"/>
          <admst:variable name="xq" string="$eq"/>
          <admst:variable name="xpq" string="$epq"/>
          <admst:variable name="e" string="_DDT($x)"/>
        </admst:when>
        <admst:when test="[name='\$param_given']">
          <admst:variable name="arg1" path="arguments[1]"/>
          <admst:assert test="$arg1[datatypename='variable']" format="\$given: argument is not a variable\n"/>
          <admst:assert test="$arg1/prototype[isparameter='yes']" format="\$given(%(name)): argument is not a parameter\n"/>
          <admst:choose>
            <admst:when test="$arg1/prototype[#parametertype!='instance']">
              <admst:variable name="e" string="_mpg(%(name),%(name)Given)"/>
            </admst:when>
            <admst:when test="$arg1/prototype[#parametertype='instance']">
              <admst:variable name="e" string="_ipg(%(name),%(name)Given)"/>
            </admst:when>
            <admst:otherwise>
              <admst:fatal format="\$given(): should not be reached\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$temperature']">
          <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:variable name="e" string="mint_get_circuit_tempK()"/>
        </admst:when>
        <admst:when test="[name='\$simparam']">
          <admst:variable name="arg1" string="%(arguments[1])"/>
          <admst:choose>
            <admst:when test="[$arg1='&quot;gmin&quot;']">
              <admst:variable name="e" string="ckt-&gt;CKTgmin"/>
            </admst:when>
            <admst:otherwise>
              <admst:fatal format="%(.) $arg1 -- not implemented in ngspice interface\n"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$mfactor']">
          <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:variable name="e" string="MFACTOR"/>
        </admst:when>
        <admst:when test="[name='\$vt']">
          <admst:choose>
            <admst:when test="[nilled(arguments)]">
              <admst:variable name="e" string="(BOLTZMANN*mint_get_circuit_tempK()/ELECTRON_CHARGE)"/>
            </admst:when>
            <admst:when test="[count(arguments)=1]">
              <admst:apply-templates select="arguments[1]" match="ddx"/>
              <admst:variable name="x" string="$e"/>
              <admst:variable name="xp" string="$ep"/>
              <admst:variable name="xq" string="$eq"/>
              <admst:variable name="xpq" string="$epq"/>
              <admst:variable name="e" string="(BOLTZMANN*$x/ELECTRON_CHARGE)"/>
            </admst:when>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$scale']">
          <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:variable name="e" string="_scale"/>
        </admst:when>
        <admst:when test="[name='\$abstime']">
          <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
          <admst:variable name="e" string="_abstime"/>
        </admst:when>
        <admst:when test="[name='ddx']">
          <admst:assert test="[count(arguments)=2]" format="%(name): should have two arguments exactly\n"/>
          <admst:assert test="arguments[2]/[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="e" string="0.0 /*ddx should be top node of expression!*/"/>
        </admst:when>
        <admst:when test="[name='floor']">
          <admst:assert test="[count(arguments)=1]" format="%(name): should have one argument exactly\n"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="e" string="floor($e)"/>
        </admst:when>
        <admst:when test="[name='ceil']">
          <admst:assert test="[count(arguments)=1]" format="%(name): should have one argument exactly\n"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="e" string="ceil($e)"/>
        </admst:when>
        <admst:when test="[$SkipFVariable='y']">
          <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
          <admst:variable name="args" string=""/>
          <admst:for-each select="arguments">
            <admst:variable test="[$args!='']" name="args" string="$args,"/>
            <admst:apply-templates select="." match="ddx"/>
            <admst:variable name="args" string="$args$e"/>
          </admst:for-each>
          <admst:variable name="e" string="$(fname)($args)"/>
        </admst:when>
        <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
          <admst:assert test="[count(arguments)=1]" format="%(name): should have one argument exactly\n"/>
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" string="$e"/>
          <admst:variable name="xp" string="$ep"/>
          <admst:variable name="xq" string="$eq"/>
          <admst:variable name="xpq" string="$epq"/>
          <admst:variable name="e" string="d00_$(fname)$index"/>
        </admst:when>
        <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
          <admst:assert test="[count(arguments)=2]" format="%(name): should have two argument exactly\n"/>
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" string="$e"/>
          <admst:variable name="xp" string="$ep"/>
          <admst:variable name="xq" string="$eq"/>
          <admst:variable name="xpq" string="$epq"/>
          <admst:apply-templates select="arguments[2]" match="ddx"/>
          <admst:variable name="y" string="$e"/>
          <admst:variable name="yp" string="$ep"/>
          <admst:variable name="yq" string="$eq"/>
          <admst:variable name="ypq" string="$epq"/>
          <admst:variable name="e" string="d00_$(fname)$index"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
          <admst:variable name="args" string=""/>
          <admst:for-each select="arguments">
            <admst:variable test="[$args!='']" name="args" string="$args,"/>
            <admst:apply-templates select="." match="ddx"/>
            <admst:variable name="args" string="$args$e"/>
          </admst:for-each>
          <admst:variable name="dargs" string=""/>
          <admst:for-each select="arguments">
            <admst:variable test="[$dargs!='']" name="dargs" string="$dargs,"/>
            <admst:apply-templates select="." match="ddx"/>
            <admst:variable name="dargs" string="$dargs$ep"/>
          </admst:for-each>
          <admst:variable name="e" string="$(fname)($args)"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="ep" string="0.0"/>
      <admst:choose>
        <admst:when test="[name='\$simparam']">
    </admst:when>
        <admst:when test="[name='absdelay']">
    </admst:when>
        <admst:when test="[name='\$param_given']">
    </admst:when>
        <admst:when test="[name='\$temperature']">
    </admst:when>
        <admst:when test="[name='\$mfactor']">
    </admst:when>
        <admst:when test="[name='\$vt']">
          <admst:choose>
            <admst:when test="[nilled(arguments)]">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[count(arguments)=1]">
              <admst:variable name="ep" string="(BOLTZMANN*$xp/ELECTRON_CHARGE)"/>
            </admst:when>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='\$scale']">
    </admst:when>
        <admst:when test="[name='\$abstime']">
    </admst:when>
        <admst:when test="[name='ddx']">
    </admst:when>
        <admst:when test="[name='floor']">
    </admst:when>
        <admst:when test="[name='ceil']">
    </admst:when>
        <admst:when test="[$SkipFVariable='y']">
    </admst:when>
        <admst:when test="[name='ddt']">
          <admst:variable name="ep" string="$xp"/>
        </admst:when>
        <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:choose>
            <admst:when test="[$xp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" string="$xp*d10_$(fname)$index"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
          <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
          <admst:choose>
            <admst:when test="[$xp='0.0' and $yp='0.0']">
              <admst:variable name="ep" string="0.0"/>
            </admst:when>
            <admst:when test="[$xp='0.0']">
              <admst:variable name="ep" string="(d11_$(fname)$index*$yp)"/>
            </admst:when>
            <admst:when test="[$yp='0.0']">
              <admst:variable name="ep" string="(d10_$(fname)$index*$xp)"/>
            </admst:when>
            <admst:otherwise>
              <admst:variable name="ep" string="(d10_$(fname)$index*$xp+d11_$(fname)$index*$yp)"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" string="d_$(fname)($args,$dargs)"/>
        </admst:otherwise>
      </admst:choose>
      <admst:if test="$qprobe">
        <admst:variable name="eq" string="0.0"/>
        <admst:choose>
          <admst:when test="[name='absdelay']">
    </admst:when>
          <admst:when test="[name='\$param_given']">
    </admst:when>
          <admst:when test="[name='\$temperature']">
    </admst:when>
          <admst:when test="[name='\$mfactor']">
    </admst:when>
          <admst:when test="[name='\$vt']">
            <admst:choose>
              <admst:when test="[nilled(arguments)]">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[count(arguments)=1]">
                <admst:variable name="eq" string="(BOLTZMANN*$xq/ELECTRON_CHARGE)"/>
              </admst:when>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='\$scale']">
    </admst:when>
          <admst:when test="[name='\$abstime']">
    </admst:when>
          <admst:when test="[name='ddx']">
    </admst:when>
          <admst:when test="[name='floor']">
    </admst:when>
          <admst:when test="[name='ceil']">
    </admst:when>
          <admst:when test="[$SkipFVariable='y']">
    </admst:when>
          <admst:when test="[name='ddt']">
            <admst:variable name="eq" string="$xq"/>
          </admst:when>
          <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
            <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
            <admst:choose>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="$xq*d10_$(fname)$index"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
            <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
            <admst:choose>
              <admst:when test="[$xq='0.0' and $yq='0.0']">
                <admst:variable name="eq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="eq" string="(d11_$(fname)$index*$yq)"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" string="(d10_$(fname)$index*$xq)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" string="(d10_$(fname)$index*$xq+d11_$(fname)$index*$yq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" string="d_$(fname)($args,$dargs)"/>
          </admst:otherwise>
        </admst:choose>
        <admst:choose>
          <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh']">
            <admst:variable name="index" string="%(index(#expression/@exfunction,.))"/>
            <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
            <admst:choose>
              <admst:when test="[$x='0.0']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xp='0.0']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:when test="[$xq='0.0']">
                <admst:variable name="epq" string="0.0"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="epq" string="(m20_$(fname)($x)*$xq*$xp+d10_$(fname)$index*$xpq)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
            <admst:variable name="epq" string="fixme"/>
            <admst:if test="[$requiredderivateforddx='yes']">
              <admst:warning format="%(name): ddx #dependency not implemented\n"/>
            </admst:if>
          </admst:when>
        </admst:choose>
      </admst:if>
    </admst:template>
    <!-- modulecode//block -->
    <admst:template match="hxxblock">
      <admst:text format="{\n"/>
      <admst:text select="blockvariablep" format="%(vtype(.)) %(name);\n"/>
      <admst:if test="blockvariablep[#insource=1]/@vpprobe">
        <admst:for-each select="blockvariablep">
          <admst:variable name="myvariable" path="."/>
          <admst:for-each select="@vpprobe">
            <admst:variable name="pprobe" path="."/>
            <admst:variable name="ddxinsidethisprobe" string="no"/>
            <admst:variable test="$myvariable/@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]" name="ddxinsidethisprobe" string="yes"/>
            <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATEFORDDX)\n"/>
            <admst:text test="[$ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
            <admst:text format="double %($myvariable/name)_%(nature/access)%(pnode/name)_%(nnode/name);\n"/>
            <admst:text format="#endif\n"/>
          </admst:for-each>
        </admst:for-each>
        <admst:for-each select="blockvariablep">
          <admst:variable name="myvariable" path="."/>
            <admst:variable name="ddxprobes"/>
            <admst:for-each select="$myvariable/@vpprobe">
              <admst:variable name="pprobe" path="."/>
              <admst:push select="$ddxprobes" path="$myvariable/@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]/$pprobe" oncompare="nature|pnode|nnode"/>
            </admst:for-each>
          <admst:text test="$ddxprobes" format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="$ddxprobes">
            <admst:variable name="pprobe" path="."/>
            <admst:for-each select="$myvariable/@vpprobe">
              <admst:variable name="qprobe" path="."/>
              <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
            </admst:for-each>
          </admst:for-each>
          <admst:text test="$ddxprobes" format="#endif\n"/>
        </admst:for-each>
      </admst:if>
      <admst:apply-templates select="blockcode" match="hxx%(datatypename)"/>
      <admst:text format="}\n"/>
    </admst:template>
    <!-- modulecode//function: ddx handling -->
    <admst:template match="function:precomputation">
      <admst:variable name="index" string="%(index(../@exfunction,.))"/>
      <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
      <admst:choose>
        <admst:when test="[name='add']">
          <admst:text format="m00_add(d00_add$index"/>
        </admst:when>
        <admst:when test="[name='div']">
          <admst:text format="m00_div(d00_div$index,d10_$(fname)$index"/>
        </admst:when>
        <admst:when test="[name='mult']">
          <admst:text format="m00_mult(d00_mult$index,d10_mult$index,d11_mult$index"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="double m00_$(fname)(d00_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
      <admst:text select="arguments" format=",%(e(.))"/>
      <admst:text format=")\n"/>
    </admst:template>
    <admst:template match="function:derivate:precomputation">
      <admst:if test="[#hasVoltageDependentFunction='yes']">
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="#if defined(_DERIVATE)\n"/>
          </admst:otherwise>
        </admst:choose>
        <admst:for-each select="@exfunction">
          <admst:variable name="index" string="%(index(../@exfunction,.))"/>
          <admst:variable name="fname" string="%(funcname(.)/[name='fname']/value)"/>
          <admst:choose>
            <admst:when test="[name='exp']">
              <admst:text test="arguments/[#dependency!='constant']" format="#define d10_exp$index d00_exp$index\n"/>
            </admst:when>
            <admst:when test="[name='add']">
              <admst:if test="arguments/[#dependency!='constant']">
                <admst:text format="#define d10_add$index 1\n"/>
                <admst:text format="#define d11_add$index 1\n"/>
              </admst:if>
            </admst:when>
            <admst:when test="[name='mult']"/>
            <admst:when test="[name='add']"/>
            <admst:when test="[name='div']">
              <admst:for-each select="arguments">
                <admst:variable name="position" string="%(position()-1)"/>
                <admst:if test="[#dependency!='constant']">
                  <admst:text format="m1$(position)_$(fname)(d1$(position)_$(fname)$index,d00_$(fname)$index,d10_$(fname)$index"/>
                  <admst:text select="../arguments" format=",%(e(.))"/>
                  <admst:text format=")\n"/>
                </admst:if>
              </admst:for-each>
            </admst:when>
            <admst:otherwise>
              <admst:for-each select="arguments">
                <admst:variable name="position" string="%(position()-1)"/>
                <admst:if test="[#dependency!='constant']">
                  <admst:text format="double m1%(position()-1)_$(fname)(d1%(position()-1)_$(fname)$index,d00_$(fname)$index"/>
                  <admst:text select="../arguments" format=",%(e(.))"/>
                  <admst:text format=")\n"/>
                </admst:if>
              </admst:for-each>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
        <admst:text format="#endif\n"/>
      </admst:if>
    </admst:template>
    <!-- modulecode//assignment -->
    <admst:template match="hxxassignment">
      <admst:variable name="assignment" path="."/>
      <admst:variable name="rhs" path="rhs"/>
      <admst:variable name="lhs" path="lhs"/>
      <admst:text test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#if defined(_DYNAMIC)\n"/>
      <admst:text test="rhs/@exfunction" format="{\n"/>
      <admst:for-each select="lhs/prototype/@vpprobe">
        <admst:variable name="pprobe" path="."/>
        <admst:variable test="$lhs/prototype/@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]" name="ddxinsidederivate" string="yes"/>
      </admst:for-each>
      <admst:apply-templates select="rhs/@exfunction" match="function:precomputation"/>
      <admst:if test="lhs/prototype[#insource=1]">
        <admst:apply-templates select="rhs[exists(@exfunction)]" match="function:derivate:precomputation"/>
      </admst:if>
      <admst:choose>
        <admst:when test="rhs[datatypename='function' and arity='nary']/[name='ddx']">
          <admst:text format="#if defined(_DDX)\n"/>
          <admst:variable name="ddxprobe" path="rhs[datatypename='function' and arity='nary']/arguments[2]"/>
          <admst:text test="lhs/prototype[#insource=1]/@vpprobe" format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="lhs/prototype[#insource=1]/@vpprobe">
            <admst:variable name="qprobe" path="."/>
            <admst:variable name="allepq"/>
            <admst:for-each select="$lhs/prototype/@vpprobe">
              <admst:variable name="pprobe" path="."/>
              <admst:choose>
                <admst:when test="$pprobe[nature=$ddxprobe/nature and pnode=$ddxprobe/pnode]">
                  <admst:apply-templates select="$rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
                  <admst:variable name="allepq" string="$allepq+($epq)"/>
                </admst:when>
                <admst:when test="$pprobe[nnode=$ddxprobe/pnode]">
                  <admst:apply-templates select="$rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
                  <admst:variable name="allepq" string="$allepq-($epq)"/>
                </admst:when>
              </admst:choose>
            </admst:for-each>
            <admst:variable name="pprobe" path="$qprobe"/>
            <admst:text test="[$requiredderivateforddx='yes']" format="%(dxname($lhs)/[name='dxname']/value)=$allepq;\n"/>
          </admst:for-each>
          <admst:text test="lhs/prototype[#insource=1]/@vpprobe" format="#endif\n"/>
          <admst:variable name="allep"/>
          <admst:variable name="qprobe"/>
          <admst:for-each select="$lhs/prototype/@vpprobe">
            <admst:variable name="pprobe" path="."/>
            <admst:choose>
              <admst:when test="$pprobe[nature=$ddxprobe/nature and pnode=$ddxprobe/pnode]">
                <admst:apply-templates select="$rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
                <admst:variable name="allep" string="$allep+($ep)"/>
              </admst:when>
              <admst:when test="$pprobe[nnode=$ddxprobe/pnode]">
                <admst:apply-templates select="$rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
                <admst:variable name="allep" string="$allep-($ep)"/>
              </admst:when>
            </admst:choose>
          </admst:for-each>
          <admst:text format="%(lhs/name)=$allep;\n"/>
          <admst:text format="EXIT_IF_ISNAN(%(lhs/name))\n"/>
          <admst:text format="#endif\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:if test="lhs/prototype[#insource=1]">
            <admst:variable name="definedrequired" string="yes"/>
            <admst:choose>
              <admst:when test="[$ddxinsidederivate='yes']">
                <admst:text format="#if defined(_DERIVATEFORDDX) /* probe=%($lhs/prototype/@vpprobe) ddxprobe=%($lhs/prototype/@ddxprobe) */\n"/>
              </admst:when>
              <admst:when test="lhs/prototype/@vpprobe">
                <admst:text format="#if defined(_DERIVATE) /* probe=%($lhs/prototype/@vpprobe) ddxprobe=%($lhs/prototype/@ddxprobe) */\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="definedrequired" string="no"/>
              </admst:otherwise>
            </admst:choose>
            <admst:for-each select="lhs/prototype/@vpprobe">
              <admst:variable name="pprobe" path="."/>
              <admst:variable name="ddxinsidethisprobe" string="no"/>
              <admst:variable test="$lhs/prototype/@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]" name="ddxinsidethisprobe" string="yes"/>
              <admst:variable name="isinside" string="0"/>
              <admst:variable test="$rhs/@exprobe[$pprobe/nature=nature and $pprobe/pnode=pnode and $pprobe/nnode=nnode]" name="isinside" string="1"/>
              <admst:variable name="qprobe"/>
              <admst:variable name="ep" string="0.0"/>
              <admst:apply-templates select="[$isinside='1']/$rhs" match="hxx%(datatypename)"/>
              <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
              <admst:text format="%(dxname($lhs)/[name='dxname']/value)=$ep;\n"/>
              <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#endif\n"/>
              <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATE2)\n"/>
              <admst:for-each select="$lhs[$ddxinsidethisprobe='yes']/prototype/@vpprobe">
                <admst:variable name="epq" string="0.0"/>
                <admst:variable name="qprobe" path="."/>
                <admst:apply-templates select="[$isinside='1']/$rhs" match="hxx%(datatypename)"/>
                <admst:text format="  %(ddxname($lhs)/[name='ddxname']/value)=$epq;\n"/>
              </admst:for-each>
              <admst:text test="$lhs[$ddxinsidethisprobe='yes']" format="#endif\n"/>
            </admst:for-each>
            <admst:text test="[$definedrequired='yes']" format="#endif\n"/>
            <admst:variable name="ddxinsidederivate" string="no"/>
          </admst:if>
          <admst:variable name="qprobe"/>
          <admst:apply-templates select="lhs" match="hxxvariable"/>
          <admst:text format="$e=%(e(rhs));\n"/>
          <admst:text format="EXIT_IF_ISNAN($e)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:text test="rhs/@exfunction" format="}\n"/>
      <admst:text test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#endif\n"/>
    </admst:template>
    <!-- modulecode//@contribution -->
    <admst:template match="hxxcontribution">
      <admst:choose>
        <admst:when test="[#modifywn=1 or #modifyfn=1]">
          <admst:variable name="SkipFVariable" string="y"/>
          <admst:error test="rhs[datatypename!='function']" format="noise term inside expression not supported!\n"/>
          <admst:if test="[#modifywn=1]">
            <admst:text test="[#dependency='constant']" format="pInst-&gt;tnoise%(index($tnoise,.))="/>
            <admst:text test="[#dependency!='constant']" format="pInst-&gt;wnoise%(index($wnoise,.))="/>
            <admst:apply-templates select="rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
            <admst:text format="$e;\n"/>
          </admst:if>
          <admst:if test="[#modifyfn=1]">
            <admst:text format="pInst-&gt;fpnoise%(index($fnoise,.))="/>
            <admst:apply-templates select="rhs[datatypename='function' and arity='nary']/arguments[1]" match="hxx%(datatypename)"/>
            <admst:text format="$e;\n"/>
            <admst:text format="pInst-&gt;fenoise%(index($fnoise,.))="/>
            <admst:apply-templates select="rhs[datatypename='function' and arity='nary']/arguments[2]" match="hxx%(datatypename)"/>
            <admst:text format="$e;\n"/>
          </admst:if>
          <admst:variable name="SkipFVariable" string="n"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="." match="contribution:nonoise"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="contribution:nonoise">
      <admst:text test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#if defined(_DYNAMIC)\n"/>
      <admst:apply-templates select="rhs/@exfunction" match="function:precomputation"/>
      <admst:apply-templates select="rhs[exists(@exfunction)]" match="function:derivate:precomputation"/>
      <admst:choose>
        <admst:when test="[#modifyd=1]">
          <admst:text format="  _load_dynamic_"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="  _load_static_"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="nnode[location!='ground']">
          <admst:text format="residual2(%(pnode/name),%(nnode/name),%(e(rhs)))\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="residual1(%(pnode/name),%(e(rhs)))\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:for-each select="rhs/@exprobe">
        <admst:variable name="probepnode" path="pnode"/>
        <admst:variable name="probennode" path="nnode"/>
        <admst:variable name="probepnodename" path="$probepnode/name"/>
        <admst:variable name="probennodename" path="$probennode/name"/>
        <admst:variable name="pprobe" path="."/>
        <admst:apply-templates select=".." match="hxx%(datatypename)"/>
        <admst:choose>
          <admst:when test="../..[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]">
            <admst:text format="  _load_dynamic_"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="  _load_static_"/>
          </admst:otherwise>
        </admst:choose>
        <admst:if test="pnode[location!='ground']">
          <admst:if test="../../pnode[location!='ground']">
            <admst:choose>
              <admst:when test="nnode[location!='ground']">
                <admst:text test="../../nnode[location!='ground']" format="jacobian4(%(../../pnode/name),%(../../nnode/name),%(pnode/name),%(nnode/name),$ep)\n"/>
                <admst:text test="../../nnode[location='ground']" format="jacobian2p(%(../../pnode/name),%(pnode/name),%(nnode/name),$ep)\n"/>
              </admst:when>
              <admst:otherwise>
                <admst:text test="../../nnode[location!='ground']" format="jacobian2s(%(../../pnode/name),%(../../nnode/name),%(pnode/name),$ep)\n"/>
                <admst:text test="../../nnode[location='ground']" format="jacobian1(%(../../pnode/name),%(pnode/name),$ep)\n"/>
              </admst:otherwise>
            </admst:choose>
          </admst:if>
        </admst:if>
      </admst:for-each>
      <admst:text test="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#endif /* _DYNAMIC */\n"/>
    </admst:template>
    <!-- modulecode//conditional -->
    <admst:template match="hxxconditional">
      <admst:text select="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#ifdef _DYNAMIC\n"/>
      <admst:text test="ifcondition/@exfunction" format="{\n"/>
      <admst:apply-templates select="ifcondition/@exfunction" match="function:precomputation"/>
      <admst:text format="if\n(%(e(ifcondition)))\n"/>
      <admst:text select="thencode[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="thencode" match="hxx%(datatypename)"/>
      <admst:text select="thencode[datatypename!='block']" format="}\n"/>
      <admst:if test="[exists(elsecode)]">
        <admst:text format="else\n"/>
        <admst:text test="elsecode[datatypename!='block']" format="{\n"/>
        <admst:apply-templates select="elsecode" match="hxx%(datatypename)"/>
        <admst:text test="elsecode[datatypename!='block']" format="}\n"/>
      </admst:if>
      <admst:text test="ifcondition/@exfunction" format="}\n"/>
      <admst:text select="[#modifys!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#endif /* if(...) */\n"/>
    </admst:template>
    <!-- modulecode//nilled -->
    <admst:template match="hxxnilled">
</admst:template>
    <!-- modulecode//whileloop -->
    <admst:template match="hxxwhileloop">
      <admst:text select="whilecode[#modifyss!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#ifdef _DYNAMIC\n"/>
      <admst:variable name="SkipFVariable" string="y"/>
      <admst:text format="while\n(%(e(whilecondition)))\n"/>
      <admst:variable name="SkipFVariable" string="n"/>
      <admst:text select="whilecode[datatypename!='block']" format="{\n"/>
      <admst:apply-templates select="whilecode" match="hxx%(datatypename)"/>
      <admst:text select="whilecode[datatypename!='block']" format="}\n"/>
      <admst:text select="whilecode[#modifyss!=1 and #modifyfn!=1 and #modifywn!=1 and #modifyc!=1]" format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
    </admst:template>
    <!-- modulecode//callfunctions -->
    <admst:template match="hxxcallfunction">
      <admst:choose>
        <admst:when test="[name='\$strobe']">printf(</admst:when>
        <admst:when test="[name='\$warning']">_warning(</admst:when>
        <admst:when test="[name='\$error']">_error(</admst:when>
        <admst:when test="[name='\$finish']">_finish(</admst:when>
        <admst:when test="[name='\$stop']">_stop(</admst:when>
        <admst:otherwise>
          <admst:fatal format="callfunction not supported: %(name)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:join select="arguments" separator=",">
    %(e(.))
    <admst:if test="[position()=1]">"\\n"</admst:if>
  </admst:join>
      <admst:text format="); fflush(stdout);\n"/>
    </admst:template>
    <!-- analog -->
    <!-- save all variables used for local declaration -->
    <admst:variable name="ddxinsidederivate" string="no"/>
    <admst:template match="variable:declaration2">
      <admst:variable name="myvariable" path="."/>
        <admst:variable name="ddxprobes"/>
        <admst:for-each select="$myvariable/@vpprobe">
          <admst:variable name="pprobe" path="."/>
          <admst:push select="$ddxprobes" path="$myvariable/@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]/$pprobe" oncompare="nature|pnode|nnode"/>
        </admst:for-each>
      <admst:variable name="myvariable" path="."/>
      <admst:if test="[tnode/up/value/datatypename='module']">
        <admst:text test="[not(#modifys=1 or #modifyfn=1 or #modifywn=1 or #modifyc=1) and #modifyd=1]" format="#if defined(_DYNAMIC)\n"/>
        <admst:text test="[(#scope!='global_model' and #scope!='global_instance')]" format="%(vtype(.)) %(name);\n"/>
        <admst:if test="[#insource=1]/@vpprobe">
          <admst:for-each select="@vpprobe">
            <admst:variable name="pprobe" path="."/>
            <admst:variable test="../@ddxprobe[nature=$pprobe/nature and pnode=$pprobe/pnode or pnode=$pprobe/nnode]" name="ddxinsidederivate" string="yes"/>
          </admst:for-each>
          <admst:choose>
            <admst:when test="[$ddxinsidederivate='yes']">
              <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
            </admst:when>
            <admst:otherwise>
              <admst:text format="#if defined(_DERIVATE)\n"/>
            </admst:otherwise>
          </admst:choose>
          <admst:text select="@vpprobe" format="double %(../name)_%(nature/access)%(pnode/name)_%(nnode/name);\n"/>
          <admst:text test="[$ddxinsidederivate='yes']" format="#if defined(_DERIVATE2)\n"/>
          <admst:for-each select="$ddxprobes">
            <admst:variable name="pprobe" path="."/>
            <admst:for-each select="$myvariable/@vpprobe">
              <admst:variable name="qprobe" path="."/>
              <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
            </admst:for-each>
          </admst:for-each>
          <admst:text test="[$ddxinsidederivate='yes']" format="#endif\n"/>
          <admst:variable name="ddxinsidederivate" string="no"/>
          <admst:text format="#endif\n"/>
        </admst:if>
        <admst:text test="[not(#modifys=1 or #modifyfn=1 or #modifywn=1 or #modifyc=1) and #modifyd=1]" format="#endif\n"/>
      </admst:if>
    </admst:template>
    <admst:template match="block:local:declaration">
      <admst:choose>
        <admst:when test="[datatypename='assignment']">
          <admst:push select="#module/@variable" path="lhs" oncompare="prototype"/>
        </admst:when>
        <admst:when test="[datatypename='block']">
          <admst:apply-templates select="blockcode" match="block:local:declaration"/>
        </admst:when>
        <admst:when test="[datatypename='conditional']">
          <admst:apply-templates select="thencode" match="block:local:declaration"/>
          <admst:apply-templates select="elsecode" match="block:local:declaration"/>
        </admst:when>
        <admst:when test="[datatypename='whileloop']">
          <admst:apply-templates select="whilecode" match="block:local:declaration"/>
        </admst:when>
        <admst:when test="[datatypename='case']">
          <admst:error format="case statement: please implement me! (local declaration)\n"/>
        </admst:when>
        <admst:when test="[datatypename='contribution']"/>
        <admst:when test="[datatypename='function' and arity='callfunction']"/>
        <admst:when test="[datatypename='nilled']"/>
        <admst:otherwise>
          <admst:fatal format="'datatypename=%(datatypename)': should not be reached %(name)\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <admst:template match="modulecode:evaluate">
      <admst:text select="$fnoise" format="pInst-&gt;fpnoise%(index($fnoise,.))=0.0; pInst-&gt;fenoise%(index($fnoise,.))=0.0;\n"/>
      <admst:text select="$tnoise" format="pInst-&gt;tnoise%(index($tnoise,.))=0.0;\n"/>
      <admst:text select="$wnoise" format="pInst-&gt;wnoise%(index($wnoise,.))=0.0;\n"/>
      <admst:for-each select="blockcode">
        <admst:if test="[datatypename='block']/[name!='initial_model' and name!='initial_instance']">
          <admst:apply-templates select="." match="block:local:declaration"/>
        </admst:if>
        <admst:if test="[datatypename!='block']">
          <admst:apply-templates select="." match="block:local:declaration"/>
        </admst:if>
      </admst:for-each>
      <admst:apply-templates select="#module/@variable/prototype" match="variable:declaration2"/>
      <admst:value-to select="#module/@variable"/>
      <admst:for-each select="blockcode">
        <admst:choose>
          <admst:when test="[datatypename!='block']">
            <admst:apply-templates select="." match="hxx%(datatypename)"/>
          </admst:when>
          <admst:otherwise>
            <admst:if test="[name!='initial_model' and name!='initial_instance']">
              <admst:apply-templates select="." match="hxxblock"/>
            </admst:if>
          </admst:otherwise>
        </admst:choose>
      </admst:for-each>
    </admst:template>
    <admst:template match="modulecode:initializeModel">
      <admst:for-each select="blockcode">
        <admst:apply-templates select="[datatypename='block' and name='initial_model']" match="block:local:declaration"/>
      </admst:for-each>
      <admst:apply-templates select="#module/@variable" match="variable:declaration"/>
      <admst:value-to select="#module/@variable"/>
      <admst:for-each select="blockcode">
        <admst:apply-templates select="[datatypename='block' and name='initial_model']" match="hxxblock"/>
      </admst:for-each>
    </admst:template>
    <admst:template match="modulecode:initializeInstance">
      <admst:for-each select="blockcode">
        <admst:apply-templates select="[datatypename='block' and name='initial_instance']" match="block:local:declaration"/>
      </admst:for-each>
      <admst:apply-templates select="#module/@variable" match="variable:declaration"/>
      <admst:value-to select="#module/@variable"/>
      <admst:for-each select="blockcode">
        <admst:apply-templates select="[datatypename='block' and name='initial_instance']" match="hxxblock"/>
      </admst:for-each>
    </admst:template>
    <!--
* This template returns the description of an instance or 
* a model parameter. It works for both formats of :
*   `ATTR(info="description"  ...)
* or
*   `ATTR(desc="description"  ...)
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no description given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'description'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
    <admst:template match="variable:desc">
      <admst:choose>
        <admst:when test="attribute[name='desc' or name='info']">
          <admst:return name="variable:desc" string="&quot;%(attribute[name='desc' or name='info']/value)&quot;"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="variable:desc" string="NULL"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <!--
* This template returns the unit of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. If there is no 'unit' string given in the VerilogA file, 
* it returns a NULL. The returned value is used in the 'unit'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
    <admst:template match="variable:unit">
      <admst:choose>
        <admst:when test="attribute[name='unit']">
          <admst:return name="variable:unit" string="&quot;%(attribute[name='unit']/value)&quot;"/>
        </admst:when>
        <admst:otherwise>
          <admst:return name="variable:unit" string="NULL"/>
        </admst:otherwise>
      </admst:choose>
    </admst:template>
    <!--
* This template returns the default value of an instance or 
* a model parameter as given in the VA file.
* This template is used in the creation of the mint:defineParameters 
* routine. The returned value is used in the 'default'
* field of the mint_param_xxx file, where xxx is [integer|real|string]
-->
    <admst:template match="variable:paramdef">
      <admst:return name="name" string="%(name)"/>
      <admst:apply-templates select="." match="variable:desc">
        <admst:return name="desc" string="%(returned('variable:desc')/value)"/>
      </admst:apply-templates>
      <admst:apply-templates select="." match="variable:unit">
        <admst:return name="unit" string="%(returned('variable:unit')/value)"/>
      </admst:apply-templates>
      <admst:return name="minttype" string="%(type)"/>
    </admst:template>
    <!-- Do not create temp variables for functions inside while(), for()-->
    <admst:variable name="requiredderivateforddx" string="no"/>
    <admst:variable name="SkipFVariable" string="n"/>
    <admst:for-each select="/@module">
      <admst:variable name="module" path="name"/>
      <admst:choose>
        <admst:when test="attribute[name='desc']">
          <admst:variable name="module:desc" path="attribute[name='desc']/value"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="module:desc" string="no description"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="file" string="%(attribute[name='ngspicename']/value).hxx"/>
      <admst:open file="$file">
        <admst:text format="\n"/>
        <admst:apply-templates select="." match="c:math_h"/>
        <admst:apply-templates select="." match="wrapper"/>
        <admst:text format="\n"/>
        <admst:apply-templates select="modulecode" match="modulecode:evaluate"/>
        <admst:message format="$file: created\n"/>
      </admst:open>
    </admst:for-each>
  </admst:if>
  <!-- ngspice -->
</admst>
